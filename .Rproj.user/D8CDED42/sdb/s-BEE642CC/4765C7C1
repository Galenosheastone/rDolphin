{
    "collab_server" : "",
    "contents" : "#' Automatic quantification in the model spectrum of the dataset using the information located in the ROI patterns file, with associated p values for every bin. The reulting information can be useful to analyze possible new ROIs to profile or modification of existing ones.\n#'\n#' @param imported_data List with typical elements necessary to perform quantification of ROIs.\n#'\n#' @return plotly figure with performed fitting for every ROI and p value for every bin\n#' @export autorun_model_spectrum\n#' @import baseline\n#' @import minpack.lm\n#'\n#' @examples\n#' setwd(paste(system.file(package = \"rDolphin\"),\"extdata\",sep='/'))\n#' imported_data=import_data(\"Parameters_MTBLS242_15spectra_5groups.csv\")\n#' model_spectrum_plot=autorun_model_spectrum(imported_data)\n\n\n\nautorun_model_spectrum = function(imported_data) {\n\n  print('Preparing quantifications in a model spectrum with the current ROI Profiles. A figure with the performed quantifications will be shown, as well as a chemometric model with the metadata given. Then you can go to change the parameters of the ROI Profiles')\n\n#Splitting of ROI data into individual ROIs to be quantified\n\tdummy = which(is.na(imported_data$ROI_data[, 1]))\n    if (length(dummy)==0) dummy=dim(imported_data$ROI_data)[1]+1\n    lal=which(duplicated(imported_data$ROI_data[-dummy,1:2])==F)\n    ROI_separator = cbind(lal, c(lal[-1] - 1, dim(imported_data$ROI_data[-dummy,])[1]))\n  \n  baselinedataset=baseline.rollingBall(imported_data$dataset,5,5)$baseline\n  # indicators=matrix(NA,nrow(imported_data$ROI_data),2,dimnames=list(imported_data$signals_names)))\n  total_signals_parameters=matrix(NA,nrow(imported_data$ROI_data),9,dimnames=list(imported_data$signals_names))\n  colnames(total_signals_parameters)=c(\"intensity\",\t\" chemical shift\",\t\"half_band_width\",\t\"gaussian %\",\t\"J coupling\",\t\"multiplicities\",\t\"roof_effect\",\"fitting error\",\"signal / total area ratio\")\n\n  quartile_spectrum = as.numeric(apply(imported_data$dataset, 2, function(x)\n    quantile(x, 0.75,na.rm=T)))\n  spectrum_index = which.min(apply(imported_data$dataset, 1, function(x)\n    sqrt(mean((x - quartile_spectrum) ^ 2\n      ,na.rm=T))))\n  plotdata = data.frame(Xdata=as.numeric(imported_data$ppm),Ydata = as.numeric(imported_data$dataset[spectrum_index,]))\n  fitted_data=rep(0,length(imported_data$ppm))\n  pb   <- txtProgressBar(1, nrow(ROI_separator), style=3)\n\n  for (ROI_index in seq_along(ROI_separator[, 1])) {\n    #Loading of every ROI parameters\n    ROI_profile = imported_data$ROI_data[ROI_separator[ROI_index, 1]:ROI_separator[ROI_index, 2],]\n    ROI_buckets = which.min(abs(as.numeric(ROI_profile[1, 1])-imported_data$ppm)):which.min(abs(as.numeric(ROI_profile[1, 2])-imported_data$ppm))\n    signals_to_quantify = which(ROI_profile[, 5] >= 1)\n    signals_codes = (ROI_separator[ROI_index, 1]:ROI_separator[ROI_index, 2])[signals_to_quantify]\n\n    #Preparation of necessary parameters\n    program_parameters=imported_data$program_parameters\n    program_parameters$freq = imported_data$freq\n    program_parameters$ROI_buckets = ROI_buckets\n    program_parameters$buck_step = imported_data$buck_step\n\n\n    fitting_type = as.character(ROI_profile[1, 3])\n    signals_to_quantify = which(ROI_profile[, 5] >= 1)\n    ROI_buckets = which.min(abs(as.numeric(ROI_profile[1, 1])-imported_data$ppm)):which.min(abs(as.numeric(ROI_profile[1, 2])-imported_data$ppm))\n    if (length(ROI_buckets)<5) next\n    if (ROI_buckets[1]>ROI_buckets[2]) ROI_buckets=rev(ROI_buckets)\n\n\n\n    Xdata= as.numeric(imported_data$ppm[ROI_buckets])\n    Ydata = as.numeric(imported_data$dataset[spectrum_index, ROI_buckets])\n\n\n\n    # If the quantification is through integration with or without baseline\n    if (fitting_type == \"Clean Sum\" ||\n        fitting_type == \"Baseline Sum\") {\n      baseline = ifelse(fitting_type == \"Clean Sum\", rep(0,length(Xdata)),seq(min(Ydata[1:5]), min(Ydata[(length(Xdata) - 4):length(Xdata)]), len=length(Xdata)))\n\n      Ydatamedian=as.numeric(apply(imported_data$dataset[, ROI_buckets,drop=F],2,median))\n\n      clean_fit = ifelse(fitting_type == \"Clean Sum\", \"Y\", \"N\")\n      integration_variables = integration(clean_fit, Xdata,Ydata,Ydatamedian)\n\n      total_signals_parameters[signals_codes,]=c(integration_variables$results_to_save$intensity,integration_variables$results_to_save$shift,rep(NA,5),integration_variables$results_to_save$fitting_error,integration_variables$results_to_save$signal_area_ratio)\n\n     \n      #preparation of output\n      fitted_data[ROI_buckets]= integration_variables$plot_data[3,]\n\n\n    } else if (fitting_type == \"Clean Fitting\" || fitting_type ==\n        \"Baseline Fitting\") {\n      is_roi_testing = \"N\"\n      program_parameters$clean_fit='N'\n\n      initial_fit_parameters = ROI_profile[, 5:11,drop=F]\n\n      #Adaptation of the info of the parameters into a single matrix and preparation (if necessary) of the background signals that will conform the baseline\n      FeaturesMatrix = fitting_prep(Xdata,\n        Ydata,\n        ROI_profile[, 5:11,drop=F],\n        program_parameters,baselinedataset[spectrum_index,ROI_buckets])\n\n      #Calculation of the parameters that will achieve the best fitting\n      dummy = fittingloop(FeaturesMatrix,\n        Xdata,\n        Ydata,\n        program_parameters)\n      signals_parameters=dummy$signals_parameters\n\n      #Fitting of the signals\n      multiplicities=FeaturesMatrix[,11]\n      roof_effect=FeaturesMatrix[,12]\n      \n\n      fitted_signals = signal_fitting(signals_parameters,\n        Xdata,multiplicities,roof_effect,Ydata,program_parameters$freq)\n      dim(signals_parameters) = c(5, length(signals_parameters)/5)\n      rownames(signals_parameters) = c(\n        'intensity',\n        'shift',\n        'half_band_width',\n        'gaussian',\n        'J_coupling'\n      )\n\n      signals_parameters=rbind(signals_parameters,multiplicities,roof_effect)\n\n\n      dummy = output_generator(\n        signals_to_quantify,\n        fitted_signals,\n        Ydata,\n        Xdata,\n        signals_parameters,multiplicities\n      )\n      output_data=dummy$output_data\n     \n      fitted_data[ROI_buckets]=output_data$fitted_sum\n    total_signals_parameters[signals_codes,]=cbind(t(signals_parameters[,signals_to_quantify]),output_data$fitting_error[signals_to_quantify],output_data$signal_area_ratio[signals_to_quantify])\n\n\n    }\n    setTxtProgressBar(pb, ROI_index)\n\n  }\n  p_value_bucketing=as.vector(p_values(imported_data$dataset,imported_data$Metadata))\n\n  ay <- list(tickfont = list(color = \"red\"),overlaying = \"y\",side = \"right\",title = \"p value\",range = c(0, max(as.numeric(imported_data$dataset[spectrum_index, ]))))\n  az = list(title = \"Intensity\",range = c(-1, max(as.numeric(imported_data$dataset[spectrum_index, ]))-1))\n  p=plot_ly()%>%\n    add_lines(x=~imported_data$ppm,y = ~as.numeric(imported_data$dataset[spectrum_index, ]),,name='Model spectrum')%>%\n    add_lines(x=~imported_data$ppm,y = ~fitted_data,name='Fitted spectrum',fill='tozeroy')%>%\n  add_lines(x=~imported_data$ppm,y = ~p_value_bucketing,name='p value', yaxis = \"y2\")%>%\n    layout(xaxis=list(title='ppm',range=c(max(imported_data$ppm),min(imported_data$ppm))),yaxis=az, yaxis2 = ay)\n  dummy=list(p=p,total_signals_parameters=round(total_signals_parameters,4),ROI_data=imported_data$ROI_data)\n  return(dummy)\n}\n",
    "created" : 1492705153235.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4065802606",
    "id" : "4765C7C1",
    "lastKnownWriteTime" : 1492506180,
    "last_content_update" : 1492506180,
    "path" : "~/GitHub/prova/R/autorun_model_spectrum.R",
    "project_path" : "R/autorun_model_spectrum.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}