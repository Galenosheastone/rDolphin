{
    "collab_server" : "",
    "contents" : "\nMetadata2Buckets <- function(Experiments, params, spectrum_borders) {\n\n  CURRENT = list()\n  RAW = list()\n  not_loaded_experiments = read_spectra =  norm_factor=c()\n\n\n  left_spectral_border = ifelse(exists(\"left_spectral_border\", where = params),\n                                params$left_spectral_border,\n    spectrum_borders[1])\n  right_spectral_border = ifelse(exists(\"right_spectral_border\", where = params),\n                                 params$right_spectral_border,\n    spectrum_borders[2])\n\n  RAW$norm_PEAK_left_ppm = ifelse(params$norm_PEAK == \"Y\", params$norm_left_ppm,\n    0)\n  RAW$norm_PEAK_right_ppm = ifelse(params$norm_PEAK == \"Y\", params$norm_left_ppm,\n    0)\n  RAW$norm_AREA_left_ppm = ifelse(params$norm_AREA == \"Y\", params$norm_left_ppm,\n                                  0)\n  RAW$norm_AREA_right_ppm = ifelse(params$norm_AREA == \"Y\", params$norm_right_ppm,\n                                   0)\n\n  tsp_alignment = params$tsp_alignment\n  ref_peak_pos = ifelse(params$peak_alignment == \"Y\", params$ref_peak_pos,\n                        0)\n\n  k2 = 1\n  maxspec = length(Experiments)\n\n  for (k in 1:maxspec) {\n    filename = paste(params$dir, Experiments[k], params$expno, \"pdata\", params$processingno, sep = \"/\")\n    partname = paste(params$dir, Experiments[k], params$expno, sep = \"/\")\n    storedpars = topspin_read_spectrum2(partname, filename,spectrum_borders[2]-0.1, spectrum_borders[1]+0.1)\n    if (all(is.nan(storedpars$real)) == 0) {\n      CURRENT$minppm = storedpars$OFFSET - storedpars$SW\n      CURRENT$maxppm = storedpars$OFFSET\n      CURRENT$step = storedpars$SW / (length(storedpars$real) - 1)\n      CURRENT$ppm = seq(CURRENT$maxppm, CURRENT$minppm,-CURRENT$step)\n\n     tmp = (storedpars$real * ((2 ^ storedpars$NC_proc) / storedpars$RG))\n\t# left_spectral_border =  floor(min(CURRENT$maxppm,left_spectral_border)*10)/10\n\t#     \tright_spectral_border =  ceiling(max(CURRENT$minppm,right_spectral_border)*10)/10\n\n     if (left_spectral_border>CURRENT$maxppm | right_spectral_border<CURRENT$minppm) {\n       print('Current incorrect spectrum borders. Please prepare a modified version of fitting_variables with appropiate spectrum borders and introduce its path on the Parameters CSV file.')\n       finaldata=NA\n       return(finaldata)\n     }\n      CURRENT$left_spectral_border = 1 + round(-(left_spectral_border -\n                                                   CURRENT$maxppm) / CURRENT$step)\n      CURRENT$norm_PEAK_left = 1 + round(-(RAW$norm_PEAK_left_ppm -\n                                             CURRENT$maxppm) / CURRENT$step)\n      CURRENT$norm_PEAK_right = 1 + round(-(RAW$norm_PEAK_right_ppm -\n                                              CURRENT$maxppm) / CURRENT$step)\n      CURRENT$norm_AREA_left = 1 + round(-(RAW$norm_AREA_left_ppm -\n                                             CURRENT$maxppm) / CURRENT$step)\n      CURRENT$norm_AREA_right = 1 + round(-(RAW$norm_AREA_right_ppm -\n                                              CURRENT$maxppm) / CURRENT$step)\n      norm_PEAK_max = max(tmp[CURRENT$norm_PEAK_left:CURRENT$norm_PEAK_right])\n      norm_PEAK_max_position = which.max(tmp[CURRENT$norm_PEAK_left:CURRENT$norm_PEAK_right])\n      norm_AREA = sum(tmp[CURRENT$norm_AREA_left:CURRENT$norm_AREA_right])\n      total_AREA_mean = mean(tmp[1:length(tmp)])\n\n      RAW$len = length(storedpars$real)\n      RAW$ofs = storedpars$OFFSET\n      RAW$sw = storedpars$SW\n      RAW$ncproc = storedpars$NC_proc\n      RAW$minppm = storedpars$OFFSET - storedpars$SW\n      RAW$maxppm = storedpars$OFFSET\n      RAW$size = length(storedpars$real)\n      RAW$step = RAW$sw / (RAW$size - 1)\n      RAW$ppm = seq(RAW$maxppm, RAW$minppm,-RAW$step)\n      RAW$buck_step = ifelse(params$buck_step < RAW$step, RAW$step,\n                             params$buck_step)\n      # redieixo la part dreta de l'espectre de Matlab RAW$ppm_bucks =\n      RAW$ppm_bucks = seq(left_spectral_border,\n                          right_spectral_border,-RAW$buck_step)\n      RAW$len_bucks = length(RAW$ppm_bucks)\n      RAW$norm_PEAK_max = norm_PEAK_max\n      RAW$total_AREA_mean = total_AREA_mean\n      RAW$norm_AREA = norm_AREA\n      RAW$differential_norm_AREA = 0\n      # }\n\n      if (params$norm_PEAK == \"Y\" &\n          norm_PEAK_max > 0)\n        tmp = tmp / norm_PEAK_max\n      if (params$norm_AREA == \"Y\" &\n          norm_AREA > 0)\n        tmp = tmp / norm_AREA\n\n      # calculem valors despres de normalitzar\n      norm_PEAK_max2 = max(tmp[CURRENT$norm_PEAK_left:CURRENT$norm_PEAK_right])\n      norm_AREA2 = sum(tmp[CURRENT$norm_AREA_left:CURRENT$norm_AREA_right])\n      # referenciem\n      LeftEreticBefore = ifelse(CURRENT$ppm[1] > 11.8, min(CURRENT$ppm[which(CURRENT$ppm > 11.7)]), NaN)\n\n      if (params$glucose_alignment == \"Y\") {\n        JTP = JTPcalibrateToGlucose(tmp, CURRENT$ppm)\n      } else if (params$tsp_alignment == \"Y\") {\n        JTP = JTPcalibrateToTSP(tmp, CURRENT$ppm)\n      } else if (params$peak_alignment == \"Y\") {\n        # if (nrow(as.matrix(ref_peak_pos)) == maxspec) {\n        #   JTP = JTPcalibrateToPeak2(tmp, CURRENT$ppm, 5.3, 0.4)\n        #   JTP = JTPcalibrateToPeak(tmp, CURRENT$ppm, ref_peak_pos[k])\n        # } else {\n          JTP = JTPcalibrateToPeak(tmp, CURRENT$ppm, ref_peak_pos)\n\t# }\n      } else {\n\tJTP=list(ppm=CURRENT$ppm)\n\t}\n      CURRENT$ppm = JTP$ppm\n      # si hi llegim zona d'eretic llavors tornem a posar Eretic a 11 ppm\n      if (!is.nan(LeftEreticBefore)) {\n        LeftEreticAfter = min(CURRENT$ppm[which(CURRENT$ppm > 11.7)])\n        RightEreticAfter = min(CURRENT$ppm[which(CURRENT$ppm > 10.8)])\n        RightEreticBefore = LeftEreticBefore + RightEreticAfter - LeftEreticAfter\n        tmp[LeftEreticAfter:RightEreticAfter] = tmp[LeftEreticBefore:RightEreticBefore]\n      }\n\n\n\n      fill2end = 0\n      tmp_count = CURRENT$left_spectral_border\n      tmp_buck = rep(0, RAW$len_bucks)\n      jumped_bucket = 0\n      for (tmp_buck_count in 2:RAW$len_bucks) {\n        items = suma = 0\n        while (CURRENT$ppm[tmp_count] > RAW$ppm_bucks[tmp_buck_count]) {\n          items = items + 1\n          suma = suma + tmp[tmp_count]\n          tmp_count = tmp_count + 1\n          if (tmp_count > length(CURRENT$ppm)) {\n            fill2end = 1\n            break\n          }\n        }\n\n\t# faig una modificacio per a corregir buckets sense dades.\n        if (items > 0) {\n          tmp_buck[tmp_buck_count - 1] = suma / items\n          while (jumped_bucket > 0) {\n            tmp_buck[tmp_buck_count - 1 - jumped_bucket] = suma / items\n            jumped_bucket = jumped_bucket - 1\n          }\n        } else {\n          jumped_bucket = jumped_bucket + 1\n        }\n        if (fill2end == 1) {\n          while (tmp_buck_count <= RAW$len_bucks) {\n            tmp_buck[tmp_buck_count] = tmp_buck[tmp_buck_count -\n                                                  1]\n            tmp_buck_count = tmp_buck_count + 1\n          }\n          break\n        }\n      }\n      while (length(tmp_buck) < RAW$len_bucks)\n        tmp_buck = c(tmp_buck, tmp_buck[length(tmp_buck)])\n\n\n      if (params$norm_PEAK == \"Y\" &\n          norm_PEAK_max > 0) {\n        normvalue=norm_PEAK_max\n      } else if (params$norm_AREA == \"Y\" &\n          norm_AREA > 0) {\n        normvalue=norm_AREA\n    } else {\n      normvalue=1\n    }\n      if (k2 == 1) dataset = matrix(NA, 0, RAW$len_bucks)\n      \n      dataset=rbind(dataset,tmp_buck[1:RAW$len_bucks])\n      norm_factor = append(norm_factor,normvalue)\n         read_spectra = append(read_spectra, as.character(Experiments[k]))\n         k2 = k2 + 1\n         \n         \n\n    } else {\n      # llista d'objectes no inclosos\n      not_loaded_experiments = append(not_loaded_experiments, Experiments[k])\n    }\n  }\n  # finaldata$params = params\n  # finaldata$RAW = RAW\n  # dataset = dataset[complete.cases(dataset),,drop=F]\n  rownames(dataset) = read_spectra\n  colnames(dataset) = as.character(RAW$ppm_bucks)\n  finaldata = list(dataset=dataset,ppm=RAW$ppm_bucks,not_loaded_experiments = not_loaded_experiments,norm_factor=norm_factor)\n\n\n  return(finaldata)\n}\n",
    "created" : 1493632419385.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3509961290",
    "id" : "5D3C69F5",
    "lastKnownWriteTime" : 1493633508,
    "last_content_update" : 1493633508,
    "path" : "~/GitHub/rDolphin/R/Metadata2Buckets.R",
    "project_path" : "R/Metadata2Buckets.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}