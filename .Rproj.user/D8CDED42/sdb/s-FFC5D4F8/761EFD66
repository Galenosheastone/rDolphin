{
    "collab_server" : "",
    "contents" : "#' Creation of matrix to validate quantifications, with information of difference with predicted shift, signal to total area ratio, fitting error, and difference with expected relative intensity\n#'\n#' @param final_output List with quantifications and indicators of quality of quantification.\n#' @param alarmmatrix List with quantifications and indicators of quality of quantification.\n#' @param validation_type Type of valdiation to perform (1: fitting error, 2: signal area ratio, 3: chemical shift, 4: half bandwidth, 5: outliers, 6: relative intensity of signals of same metabolite)\n#'\n#' @return Matrix with data required\n#' @export validation\n#' @import ranger\n#'\n#' @examples\n#' setwd(paste(system.file(package = \"rDolphin\"),\"extdata\",sep='/'))\n#' load(\"MTBLS242_subset_example.RData\")\n#' validation_data=validation(quantification_variables$final_output,quantification_variables$alarmmatrix,5)\n\n\n\nvalidation = function(final_output,alarmmatrix,validation_type) {\nprint(\"Updating the chosen validation method...\")\nif (is.null(alarmmatrix)) {\n  alarmmatrix=final_output\nfor (i in seq(length(alarmmatrix))) alarmmatrix[[i]][,]=NA\n}\n if (validation_type==\"0\") validation_type=1\n  tec=apply(final_output$half_band_width,2,function(x)!all(is.na(x)))\n  final_output$shift[final_output$shift==Inf]=NA\n  final_output$shift=suppressWarnings(tryCatch(missForest::missForest(lol)$ximp,error=function(e) final_output$shift))\n  final_output$half_band_width[,tec]=suppressWarnings(tryCatch(missForest::missForest(lol)$ximp,error=function(e) final_output$half_band_width[,tec]))\n  final_output$intensity=suppressWarnings(tryCatch(missForest::missForest(lol)$ximp,error=function(e) final_output$intensity))\n\n\n  indexes=sapply(seq(ncol(final_output$signal_area_ratio)),function(x)identical(final_output$signal_area_ratio[,x],alarmmatrix$signal_area_ratio[,x]))\nindexes=which(indexes==F)\n  ind=which(apply(final_output$shift,2,function(x)length(which(is.na(x))))<0.5*nrow(final_output$shift))\n  for (i in intersect(ind,indexes)) {\n\n    shift3=data.frame(y=final_output$shift[,i],d=final_output$shift[,setdiff(ind,i)])\n    alarmmatrix$shift[,i]=predict(ranger::ranger(y~.,data=shift3,mtry=3),shift3)$predictions-final_output$shift[,i]\n  }\n  ind=which(apply(final_output$half_band_width,2,function(x)length(which(is.na(x))))<0.5*nrow(final_output$half_band_width))\n  for (i in intersect(ind,indexes)) {\n    shift3=data.frame(y=final_output$half_band_width[,i],d=final_output$half_band_width[,setdiff(ind,i)])\n    alarmmatrix$half_band_width[,i]=predict(ranger::ranger(y ~.,data=shift3,mtry=3),shift3)$predictions/final_output$half_band_width[,i]\n  }\n  ind=which(apply(final_output$intensity,2,function(x)length(which(is.na(x))))<0.5*nrow(final_output$intensity))\n  for (i in intersect(ind,indexes)) {\n    shift3=data.frame(y=final_output$intensity[,i],d=final_output$intensity[,setdiff(ind,i)])\n    alarmmatrix$intensity[,i]=predict(ranger::ranger(y~.,data=shift3,mtry=3),shift3)$predictions/final_output$intensity[,i]\n  }\n\n  alarmmatrix$fitting_error=final_output$fitting_error\n  alarmmatrix$signal_area_ratio=final_output$signal_area_ratio\n\n  if (validation_type==1) {\n    shownmatrix=alarmmatrix$fitting_error\n  brks <- seq(0.01,0.19,0.01)\n  clrs <- round(seq(255, 40, length.out = length(brks) + 1), 0) %>%\n  {paste0(\"rgb(255,\", ., \",\", ., \")\")}\n\n\t#Analysis of which quantifications have too low signal to toal area ratio\n\n} else if (validation_type==2) {\n  shownmatrix=alarmmatrix$signal_area_ratio\n  brks <- seq(0,20,length.out=19)\n  clrs <- round(seq(40, 255, length.out = length(brks) + 1), 0) %>%\n  {paste0(\"rgb(255,\", ., \",\", ., \")\")}\n\n\t#Analysis of which quantifications deviate too much from expected shift, according to prediction with linear model of signals with similar behavior\n\n} else if (validation_type==3) {\n  shownmatrix=alarmmatrix$shift\n  brks <-c(-seq(max(abs(shownmatrix),na.rm=T), 0, length.out=10),seq(0, max(abs(shownmatrix),na.rm=T), length.out=10)[-1])\n  clrs <- round(c(seq(40, 255, length.out = (length(brks) + 1)/2),seq(255, 40, length.out = (length(brks) + 1)/2)), 0) %>%\n  {paste0(\"rgb(255,\", ., \",\", ., \")\")}\n  \t#Analysis of which quantifications deviate too much from expected half_band_width, according to prediction with linear model of spectra with similar behavior\n\n  } else if (validation_type==4) {\n    shownmatrix=alarmmatrix$half_band_width\n    brks <- c(seq(0.25, 1,length.out = 10), seq(1, 4, length.out = 10)[-1])\n    clrs <- round(c(seq(40, 255, length.out = (length(brks) + 1)/2),seq(255, 40, length.out = (length(brks) + 1)/2)), 0) %>%\n  {paste0(\"rgb(255,\", ., \",\", ., \")\")}\n\n  #Analysis of outliers for every class and of their magnitude\n\n  } else if (validation_type==5) {\n    shownmatrix=alarmmatrix$intensity\n     brks <- c(seq(0.25, 1,length.out = 10), seq(1, 4, length.out = 10)[-1])\n    clrs <- round(c(seq(40, 255, length.out = (length(brks) + 1)/2),seq(255, 40, length.out = (length(brks) + 1)/2)), 0) %>%\n    {paste0(\"rgb(255,\", ., \",\", ., \")\")}\n\n}\nvalidationdata=list(alarmmatrix=alarmmatrix,shownmatrix=shownmatrix,brks=brks,clrs=clrs)\nprint(\"Done!\")\n\nreturn(validationdata)\n}\n",
    "created" : 1506154982298.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "51375930",
    "id" : "761EFD66",
    "lastKnownWriteTime" : 1506155744,
    "last_content_update" : 1506155744584,
    "path" : "~/GitHub/rDolphin/R/validation.R",
    "project_path" : "R/validation.R",
    "properties" : {
    },
    "relative_order" : 10,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}