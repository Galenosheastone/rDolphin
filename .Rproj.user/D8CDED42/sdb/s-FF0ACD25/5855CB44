{
    "collab_server" : "",
    "contents" : "\n\nserver = function(input, output,session) {\n\n  #Increase of maximum memory size that can be uploaded\n  options(shiny.maxRequestSize=1000*1024^2)\n\n  #Setting of reactive parameters in the Shiny GUI\n  reactiveROItestingdata <- reactiveValues(signpar = matrix(NA,2,7,dimnames = list(seq(2),c(\"intensity\",\t\"chemical shift\",\t\"half bandwidth\",\t\"gaussian %\",\t\"J coupling\",\t\"multiplicities\",\t\"roof effect\"))),qualitypar = matrix(NA,2,3,dimnames=list(seq(2),c('Quantification','fitting_error','signal/total area ratio'))))\n  reactivequantdata <- reactiveValues(method1=NA)\n reactiveprogramdata <- reactiveValues(ROIdata_subset=NA,ind=NA,beginning=FALSE,dataset=NA,final_output=list(),useful_data=list(),imported_data=NA,p_value_final=NA,ROI_data=NA,ROI_data_check=NA,info=c(),select_options=NA,new_roi_profile=NA,p=NA,bgColScales=NA,autorun_plot=NA,ROI_names=NA,clusterplot=NA,medianplot=NA,jres_plot=NA)\n\n  ## FIRST TAB REACTIVE OUTPUTS\n\n  #Read of input provided by user\n  observeEvent(input$file1, {\n    reactiveprogramdata$inFile <- input$file1\n    if (is.null(reactiveprogramdata$inFile)) {\n      return(NULL)\n    }\n\n\t#Imported data is loaded to 'dummy'. Only after the check that the parameters are correct, they are stored in 'reactiveprogramdata'.\n\t# dummy=list(imported_data=NA,autorun_plot=NA,select_options=NA,spectra=NA,clusterplot=NA,medianplot=NA,beginning=FALSE,jres_plot=NA)\n\t# Import of data\n\t# dummy = tryCatch({helperimport(reactiveprogramdata$inFile$datapath,dummy)\n\t  # }, error = function(e) {\n\t# print('Error. Please explain the issue in the Github page if necessary.')\n\t# return(dummy)\n\t# })\n\ttryCatch({\n\treactiveprogramdata$imported_data = tryCatch({suppressWarnings(import_data(reactiveprogramdata$inFile$datapath))}, error = function(e) {\n\t  print('Import of data not posible with current input')\n\t  return(NULL)\n\t})\n  reactiveprogramdata$final_output=reactiveprogramdata$imported_data$final_output\n\treactiveprogramdata$useful_data=reactiveprogramdata$imported_data$useful_data\n\treactiveprogramdata$ROI_data=reactiveprogramdata$ROI_data_check=reactiveprogramdata$imported_data$ROI_data\n\treactiveprogramdata$imported_data$final_output=reactiveprogramdata$imported_data$useful_data=reactiveprogramdata$imported_data$ROI_data=NULL\n\n\tdummy=tryCatch({profile_model_spectrum(reactiveprogramdata$imported_data,reactiveprogramdata$ROI_data)}, error = function(e) {\n\tprint('Automatic quantification of model spectrum not possible.')\n\t})\n\treactiveprogramdata$autorun_plot=dummy$p\n\treactiveprogramdata$total_signals_parameters=dummy$total_signals_parameters\n\t# dummy$indicators=dummy2$indicators\n\n\tprint('Generating additional information...')\n\n\t#plots of representative spectra and median spectra per group to help setting the right ROI parameters\n\n    reactiveprogramdata$clusterplot=tryCatch({clustspectraplot(reactiveprogramdata$imported_data)  }, error = function(e) {\n\tprint('Generation of subsets or representative spectra not possible.')\n\t})\n    reactiveprogramdata$medianplot=tryCatch({medianplot(reactiveprogramdata$imported_data)\n\t  }, error = function(e) {\n\tprint('Generation of median spectra not possible.')\n\t})\n\n    #Subsetting of ROIs is prepared\n    #Names of ROIS and cluster and median spectra are prepared\n\tdummy=NULL\n\tdummy=tryCatch({roifunc(reactiveprogramdata$ROI_data,reactiveprogramdata$imported_data$Metadata,reactiveprogramdata$imported_data$Experiments)\n  }, error = function(e) {\n\tprint('Generation of Regions of Interest not possible. Please explain the issue in the Github page.')\n\treturn(NULL)\n\t})\n\tif (!is.null(dummy)) {\n\treactiveprogramdata$select_options=dummy$select_options\n\treactiveprogramdata$spectra=dummy$spectra\n\treactiveprogramdata$beginning =TRUE\n\n\treactiveprogramdata$jres_plot=tryCatch(twod_data(reactiveprogramdata$imported_data$jres_path), error = function(e) NA)\n\n\t# if (dummy$beginning==TRUE) {\n\t  # plo=names(sapply(dummy, names))\n\t  # for (i in 1:length(plo)) reactiveprogramdata[[plo[i]]]=dummy[[plo[i]]]\n\n\t #Variables that can change during the use of the GUI are separated from 'imported_data'.\n\n\n\t#When the session is prepared, the tabs and some inputs become active\n\tprint('Done!')\n\n    updateSelectInput(session, \"select\",choices = reactiveprogramdata$select_options,selected = 1)\n    updateSelectInput(session, \"select_validation\",selected = 1)\n    session$sendCustomMessage('activeNavs', 'Individual Quantification')\n    session$sendCustomMessage('activeNavs', 'Quantification Validation')\n    session$sendCustomMessage('activeNavs', 'Uni and multivariate analysis')\n    session$sendCustomMessage('activeNavs', 'ROI Profiles')\n    session$sendCustomMessage('activeNavs', 'STOCSY and dendrogram heatmaps')\n\t}}, error = function(e) {\n\t  print('Error. Please explain the issue in the Github page.')\n\t  reactiveprogramdata$imported_data=NA\n\t  return(reactiveprogramdata$imported_data)\n\t})\n\n\t})\n\n\n\n  #Loading of previous session\n\n    #Read of input provided by user\n  observeEvent(input$file2, {\n    reactiveprogramdata$inFile2 <- input$file2\n    if (is.null(reactiveprogramdata$inFile2))\n      return(NULL)\n\n    #Session is loaded in 'savedreactiveddata' variable and passed to 'reactiveprogramdata'.\n    tryCatch({load(reactiveprogramdata$inFile2$datapath)\n      print(\"Uploading saved session.\")\n      plo=names(sapply(savedreactivedata, names))\n      for (i in 1:length(plo)) reactiveprogramdata[[plo[i]]]=savedreactivedata[[plo[i]]]\n      rm(savedreactivedata)\n    }, error = function(e) {\n      print('Not possible to load the session. Please revise your choice.')\n      return(NULL)\n    })\n\n    reactiveprogramdata$ROI_data_check=reactiveprogramdata$ROI_data\n    #Names of ROIS are prepared\n\tdummy=NULL\n\tdummy=tryCatch({roifunc(reactiveprogramdata$ROI_data,reactiveprogramdata$imported_data$Metadata,reactiveprogramdata$imported_data$Experiments)\n  }, error = function(e) {\n\tprint('Generation of Regions of Interest not possible. Please explain the issue in the Github page.')\n\treturn(NULL)\n\t})\n\tif (!is.null(dummy)) {\n\treactiveprogramdata$select_options=dummy$select_options\n\treactiveprogramdata$spectra=dummy$spectra\n\treactiveprogramdata$beginning =TRUE\n\tprint(\"Done!\")\n\n    #When the session is loaded the tabs and some inputs become active\n    updateSelectInput(session, \"select\",choices = reactiveprogramdata$select_options,selected = 1)\n    updateSelectInput(session, \"select_validation\",selected = 1)\n    session$sendCustomMessage('activeNavs', 'Individual Quantification')\n    session$sendCustomMessage('activeNavs', 'Quantification Validation')\n    session$sendCustomMessage('activeNavs', 'Uni and multivariate analysis')\n    session$sendCustomMessage('activeNavs', 'ROI Profiles')\n    session$sendCustomMessage('activeNavs', 'STOCSY and dendrogram heatmaps')\n    updateTabsetPanel(session, \"mynavlist\",selected = \"Individual Quantification\")\n\n\t}\n  })\n\n\n\n\n  #Choice and storage of data associated to session\n  observeEvent(input$save, {\n    tryCatch({\n      print('Saving information...')\n    savedreactivedata=isolate(reactiveValuesToList(reactiveprogramdata))\n    save(savedreactivedata, file=input$caption)\n      export_path=paste(gsub(\".RData\",\"\",input$caption),'associated_data',sep='_')\n      write_info(export_path, reactiveprogramdata$final_output, reactiveprogramdata$ROI_data)\n      print('Done!')\n    },error=function(e) {print('Not possible to generate the output the session files. Please revise the path given.')})\n  })\n\nobserveEvent(input$folder, {\n  tryCatch({\n    write_plots(input$caption,reactiveprogramdata$final_output,reactiveprogramdata$imported_data,reactiveprogramdata$useful_data)},\n    error= function(e) {       print('Not possible to generate the plot folder. Please check that you have permissions for the path specified.')\n\n})})\n\n\n\n  #Appearance of autorun and aligment buttons only after beginning or loading session\n  output$varselect <- renderUI({\n    if(reactiveprogramdata$beginning==FALSE){return()}\n    actionButton('autorun', 'Autorun all spectra')\n  })\n  output$align_button <- renderUI({\n    if(reactiveprogramdata$beginning==FALSE){return()}\n    actionButton('alignment', 'Alignment of signals')\n  })\n  output$model_button <- renderUI({\n    if(reactiveprogramdata$beginning==FALSE){return()}\n    actionButton('model_spectrum', 'Profile model spectrum again')\n  })\n  output$sp = DT::renderDataTable(\n    reactiveprogramdata$total_signals_parameters , selection = list(selected = NULL),server = TRUE)\n\n#Removed by now because it is unstable.\n # output$peak_analysis <- renderUI({\n  #   if(reactiveprogramdata$beginning==FALSE){return()}\n  #   actionButton('peak_analysis', 'Peak analysis')\n  # })\n\n   #Automatic quantification of all ROIs in all spectra\n  observeEvent(input$autorun, {\n    tryCatch({\n    quantification_variables = autorun(reactiveprogramdata$imported_data, reactiveprogramdata$final_output,reactiveprogramdata$useful_data,reactiveprogramdata$ROI_data)\n    reactiveprogramdata$final_output=quantification_variables$final_output\n    reactiveprogramdata$useful_data=quantification_variables$useful_data\n    },\n    error = function(e) {\n      print('Error. Please explain the issue in the Github page if necessary.')\n      quantification_variables=NA\n      return(quantification_variables)\n    })\n  })\n  #Alignment of signals\n  tryCatch({observeEvent(input$alignment, {\n    reactiveprogramdata$imported_data$dataset= alignment(reactiveprogramdata$imported_data$dataset,reactiveprogramdata$imported_data$buck_step)\n      reactiveprogramdata$clusterplot=clustspectraplot(reactiveprogramdata$imported_data)\n      reactiveprogramdata$medianplot=medianplot(reactiveprogramdata$imported_data)\n      }\t)}, error = function(e) {\n\tprint('Error during alignment. Please explain the issue in the Github page if necessary.')\n\treturn(NULL)\n\n  })\n   #Automatic quantification of all ROIs in all spectra\n  observeEvent(input$model_spectrum, {\n    tryCatch({\n    dummy=profile_model_spectrum(reactiveprogramdata$imported_data,reactiveprogramdata$ROI_data)\n    reactiveprogramdata$autorun_plot=dummy$p\n    reactiveprogramdata$total_signals_parameters=dummy$total_signals_parameters\n    }, error = function(e) {\n      print('Automatic quantification of model spectrum not possible.')\n    })\n  })\n\n  #Peak analysis. UNSTABLE!!!\n  # observeEvent(input$peak_analysis, {\n  #   if (is.null(reactiveprogramdata$alignment_check)) {\n  #     print('Before analysing peaks, I have to align them. Then I\\'ll analyze them')\n  #     dummy=alignment(reactiveprogramdata$imported_data$dataset,reactiveprogramdata$imported_data$buck_step)\n  #     peak_analysis(dummy,reactiveprogramdata$imported_data$ppm,reactiveprogramdata$imported_data$freq,reactiveprogramdata$imported_data$export_path,reactiveprogramdata$imported_data$Metadata,reactiveprogramdata$imported_data$repository,reactiveprogramdata$originaldataset)\n  #   } else {\n  #     peak_analysis(reactiveprogramdata$imported_data$dataset,reactiveprogramdata$imported_data$ppm,reactiveprogramdata$imported_data$freq,reactiveprogramdata$imported_data$export_path,reactiveprogramdata$imported_data$Metadata,reactiveprogramdata$imported_data$repository,reactiveprogramdata$originaldataset)\n  #   }\n  # })\n\n  #Plot where quantification of model spectrum amnd p values for every bucket are stored\n  output$autorun_plot <- renderPlotly({\n    if (reactiveprogramdata$beginning==FALSE) return()\n    reactiveprogramdata$autorun_plot\n  })\n\n\n\n  ## SECOND TAB REACTIVE OUTPUTS\n\n  #Selection of ROI\n\n\n  # ROI parameters are loaded when a ROI is selected\n  observeEvent(input$select, {\n    if (reactiveprogramdata$beginning==FALSE) return()\n\t#Splitting of ROI data into individual ROIs to be quantified\n    tryCatch({\n\n    dummy = which(is.na(reactiveprogramdata$ROI_data[, 1]))\n    if (length(dummy)==0) dummy=dim(reactiveprogramdata$ROI_data)[1]+1\n    lal=which(duplicated(reactiveprogramdata$ROI_data[-dummy,1:2])==FALSE)\n    ROI_separator = cbind(lal, c(lal[-1] - 1, dim(reactiveprogramdata$ROI_data[-dummy,])[1]))\n      reactiveprogramdata$ROIdata_subset=reactiveprogramdata$ROI_data[ROI_separator[as.numeric(input$select), 1]:ROI_separator[as.numeric(input$select), 2],]\n    reactiveROItestingdata$ROIpar <- reactiveprogramdata$ROIdata_subset\n    reactiveROItestingdata$signpar <- rbind(rep(NA,7),rep(NA,7))\n    colnames(reactiveROItestingdata$signpar)=c(\"intensity\",\t\"chemical shift\",\t\"half bandwidth\",\t\"gaussian %\",\t\"J coupling\",\t\"multiplicities\",\t\"roof effect\")\n    reactiveROItestingdata$qualitypar <- rbind(rep(NA,3),rep(NA,3))\n    rownames(reactiveROItestingdata$qualitypar)=NULL\n    colnames(reactiveROItestingdata$qualitypar)=c('Quantification','fitting_error','signal/total area ratio')\n\n    # Plot is prepared\n    ROI_limits=c(reactiveprogramdata$imported_data$ppm[which.min(abs(reactiveprogramdata$imported_data$ppm-reactiveprogramdata$ROIdata_subset[1,1]))],reactiveprogramdata$imported_data$ppm[which.min(abs(reactiveprogramdata$imported_data$ppm-reactiveprogramdata$ROIdata_subset[1,2]))])\n    ind=ifelse(is.null(input$x1_rows_selected),1,input$x1_rows_selected)\n    dummy=type_plot(reactiveprogramdata$imported_data,ROI_limits,ind,reactiveprogramdata$medianplot,reactiveprogramdata$clusterplot)\n    if (!is.null(dummy)) reactiveprogramdata$plot=dummy\n    }, error = function(e) {\n      print('Error. Please explain the issue on Github website.')\n      return()\n    })\n\t#Setting of reactivity to edition of parameters prepared. Probably improvable, but it is a delicate matter. Now that I can debug it easily, it can be 'cleaned' in the future.\n    reactiveprogramdata$change=reactiveprogramdata$change2=1\n    reactiveprogramdata$stop=reactiveprogramdata$stop2=0\n\n    reactiveprogramdata$info=c()\n\n\t  # Tables of ROI paramters ('ROIpar'), calculated deconvolution parameters ('signpar') and indicators of quantification ('qualitypar') are reset\n\t  resetInput(session, \"ROIdata_edit\")\n    resetInput(session, \"directedition_edit\")\n\n\t#Analysis of ROI edition. If edition is not correct (for example, there are characters in a numeric input), the edition is rejected and shown with red colour. If correct, the change is accepted with green colour.\n\t#TODO: it seems sometiems the edition fails if the change was too quick. Revise possible ways to control it.\n    output$ROIdata <- renderD3tf({\n      tableProps <- list(\n        btn_reset = FALSE,\n        sort = TRUE,\n        sort_config = list(\n          sort_types = c(\"String\", rep(\"Number\", ncol(reactiveprogramdata$ROIdata_subset)))\n        ))\n\n      d3tf(reactiveROItestingdata$ROIpar,\n           tableProps = tableProps,\n           enableTf = FALSE,\n           edit=TRUE,\n           tableStyle = \"table table-bordered\")\n\n    })\n    observe({\n      # if(is.null(input$ROIdata_edit)|(reactiveprogramdata$stop==1)) {\n      #   reactiveprogramdata$change=0\n      #   return(NULL)\n      # }\n\n      edit <- input$ROIdata_edit\n      isolate({\n        if (is.null(edit)) return()\n        id <- edit$id\n        row <- as.integer(edit$row)\n        col <- as.integer(edit$col)\n        val <- edit$val\n\n        if(col == 0) {\n          oldval <- rownames(reactiveROItestingdata$ROIpar)[row]\n        } else if (col %in% c(1:2,6:11)){\n          # numeric columns\n          if(is.na(suppressWarnings(as.numeric(val)))) {\n            oldval <- reactiveROItestingdata$ROIpar[row, col]\n            rejectEdit(session, tbl = \"ROIdata\", row = row, col = col, id = id, value = oldval)\n            # reactiveprogramdata$roi=0\n            return(NULL)\n          }\n        } else if (col %in% c(3)) {\n          if(!val %in% c('Clean Sum','Baseline Sum','Clean Fitting','Baseline Fitting')) {\n            oldval <- reactiveROItestingdata$ROIpar[row, col]\n            rejectEdit(session, tbl = \"ROIdata\", row = row, col = col, id = id, value = oldval)\n            return(NULL)\n          }\n        }\n        # if (reactiveprogramdata$change==1){\n        #   reactiveprogramdata$change=0\n        #   reactiveprogramdata$stop=1\n        #   disableEdit(session, \"ROIdata\", c(1:11))\n        # } else{\n          if(col == 0) {\n          } else if (col %in% c(1:2,5:11)) {\n            reactiveROItestingdata$ROIpar[row, col] <- as.numeric(val)\n            # reactiveprogramdata$roi=1\n          } else if (col %in% c(3,4)) {\n            reactiveROItestingdata$ROIpar[row, col] <- val\n          }\n          confirmEdit(session, tbl = \"ROIdata\", row = row, col = col, id = id, value = val)\n        # }\n      })\n    })\n    })\n\n\n\n\n  #Selection of spectra, or of cluster or median plots\n  observeEvent(input$x1_rows_selected, {\n    if (reactiveprogramdata$beginning==FALSE) return()\n    if (reactiveprogramdata$beginning ==TRUE) {\n\tdummy = which(is.na(reactiveprogramdata$ROI_data[, 1]))\n    if (length(dummy)==0) dummy=dim(reactiveprogramdata$ROI_data)[1]+1\n    lal=which(duplicated(reactiveprogramdata$ROI_data[-dummy,1:2])==FALSE)\n    ROI_separator = cbind(lal, c(lal[-1] - 1, dim(reactiveprogramdata$ROI_data[-dummy,])[1]))\n\n      reactiveprogramdata$ROIdata_subset=reactiveprogramdata$ROI_data[ROI_separator[as.numeric(input$select), 1]:ROI_separator[as.numeric(input$select), 2],]\n    }\n\t#Reset of parameters\n    # reactiveprogramdata$change=reactiveprogramdata$change2=1\n    reactiveprogramdata$stop=reactiveprogramdata$stop2=0\n\n\n    #reactivequantdata$stop3=0\n        #reactiveprogramdata$roi=NULL\n    reactiveprogramdata$info=c()\n\tresetInput(session, \"directedition_edit\")\n    # reactiveROItestingdata$ROIpar <- reactiveprogramdata$ROIdata_subset\n    reactiveROItestingdata$signpar <- rbind(rep(NA,7),rep(NA,7))\n    colnames(reactiveROItestingdata$signpar)=c(\"intensity\",\t\"shift\",\t\"half_band_width\",\t\"gaussian\",\t\"J_coupling\",\t\"multiplicities\",\t\"roof_effect\")\n    reactiveROItestingdata$qualitypar <- rbind(rep(NA,3),rep(NA,3))\n    rownames(reactiveROItestingdata$qualitypar)=NULL\n\n    colnames(reactiveROItestingdata$qualitypar)=c('Quantification','fitting_error','signal/total area ratio')\n    ROI_limits=c(reactiveprogramdata$imported_data$ppm[which.min(abs(reactiveprogramdata$imported_data$ppm-reactiveprogramdata$ROIdata_subset[1,1]))],reactiveprogramdata$imported_data$ppm[which.min(abs(reactiveprogramdata$imported_data$ppm-reactiveprogramdata$ROIdata_subset[1,2]))])\n\n\t#Generation of plot\n    dummy=type_plot(reactiveprogramdata$imported_data,ROI_limits,input$x1_rows_selected,reactiveprogramdata$medianplot,reactiveprogramdata$clusterplot)\n    if (!is.null(dummy)) reactiveprogramdata$plot=dummy\n  })\n\n  #Individual quantification\n  observeEvent(input$action, {\n    tryCatch({\n\t#Only when there is a spectrum selected and with number >2 (to avoid cluster and median plot) the quantifications is performed, with prior adaptation to row of dataset\n    if(length(reactiveprogramdata$info)==0) reactiveprogramdata$ind=input$x1_rows_selected-2\n    if (length(reactiveprogramdata$ind)!=1|reactiveprogramdata$ind<1) {\n      print('Select one valid spectrum')\n      return(NULL)\n    }\n\n\t#The automatic quantification\n    reactivequantdata$method1 <- tryCatch({not_automatic_quant(reactiveprogramdata$imported_data, reactiveprogramdata$final_output, reactiveprogramdata$ind,reactiveROItestingdata$ROIpar,reactiveprogramdata$useful_data,interface=TRUE)},error=function(e) {\n      print(\"There was a problem.\")\n      return(NULL)\n      })\n\n\t#Update of tables of tab\n    if (!is.null(reactivequantdata$method1$results_to_save)) {\n      reactiveprogramdata$plot=reactivequantdata$method1$p\n      #reactivequantdata$stop3=1\n      reactiveROItestingdata$qualitypar=cbind(reactivequantdata$method1$results_to_save$quantification,reactivequantdata$method1$results_to_save$fitting_error,reactivequantdata$method1$results_to_save$signal_area_ratio)\n      colnames(reactiveROItestingdata$qualitypar)=c('Quantification','Fitting Error','Signal/total area ratio')\n      rownames(reactiveROItestingdata$qualitypar)=rownames(reactivequantdata$method1$plot_data)[4:(3+nrow(reactiveROItestingdata$qualitypar))]\n      ind=which(rownames(reactiveROItestingdata$qualitypar)=='additional signal')\n      # reactiveprogramdata$bgColScales = rep(c(\"\",\"info\"),times=c(length(rownames(reactiveROItestingdata$qualitypar))-length(ind),length(ind)))\n      if (!is.null(reactivequantdata$method1$signals_parameters)) reactiveROItestingdata$signpar <- t(reactivequantdata$method1$signals_parameters)\n      reactiveprogramdata$stop=0\n         # reactiveprogramdata$roi=1\n    }\n    },error=function(e) {\n      print(\"Problem. Please explain the issue in the Github page\")\n    })\n  })\n\n\n\n  #Quantification of all spectra in the ROI:\n  observeEvent(input$autorun_signal, {\n    is_autorun='Y'\n    tryCatch({\n    dummy <- not_automatic_quant(reactiveprogramdata$imported_data, reactiveprogramdata$final_output, seq(nrow(reactiveprogramdata$imported_data$dataset)),reactiveROItestingdata$ROIpar,reactiveprogramdata$useful_data,interface=TRUE)\n    reactiveprogramdata$final_output=dummy$final_output\n    reactiveprogramdata$useful_data=dummy$useful_data\n\n    },error=function(e) {print('Error. Please explain the issue on the Github website')})\n    })\n\n\n\n  #Remove quantification or save quantification or ROI profile edited\n  observeEvent(input$remove_q, {\n    tryCatch({\n    if (!is.null(reactiveprogramdata$imported_data$signals_names[reactiveprogramdata$info$col])) {\n      ind=which(reactiveprogramdata$ROI_data[,4]==reactiveprogramdata$imported_data$signals_names[reactiveprogramdata$info$col])\n    } else {\n      ind=as.numeric(input$select)\n    }\n    reactiveprogramdata$final_output <- remove_quant(reactiveprogramdata$info,reactiveprogramdata$imported_data, reactiveprogramdata$final_output)\n    },error=function(e) {print('Error. Please explain the issue on the Github website')})\n\n    })\n\n  observeEvent(input$save_results, {\n    tryCatch({\n    if (is.null(reactivequantdata$method1$Ydata)) return(NULL)\n\n    dummy=save_roi_testing(reactivequantdata$method1,reactiveprogramdata$imported_data, reactiveprogramdata$final_output,reactiveprogramdata$useful_data)\n    reactiveprogramdata$final_output=dummy$final_output\n    reactiveprogramdata$useful_data=dummy$useful_data\n    },error=function(e) {print('Error. Please explain the issue on the Github website')})\n      })\n\n\n\n    #Save edition of ROI profile\n  observeEvent(input$save_profile, {\n    tryCatch({\n  dummy = which(is.na(reactiveprogramdata$ROI_data[, 1]))\n    if (length(dummy)==0) dummy=dim(reactiveprogramdata$ROI_data)[1]+1\n    lal=which(duplicated(reactiveprogramdata$ROI_data[-dummy,1:2])==FALSE)\n    ROI_separator = cbind(lal, c(lal[-1] - 1, dim(reactiveprogramdata$ROI_data[-dummy,])[1]))\n    if (length(reactiveprogramdata$info$col)>0) {\n\n      ind=which(ROI_separator[,2]-reactiveprogramdata$info$col>=0)[1]\n    } else {\n      ind=as.numeric(input$select)\n    }\n\n    reactiveprogramdata$ROI_data[ROI_separator[ind, 1]:ROI_separator[ind, 2],]=reactiveprogramdata$ROI_data_check[ROI_separator[ind, 1]:ROI_separator[ind, 2],]=reactiveROItestingdata$ROIpar\n    ROI_names=paste(reactiveprogramdata$ROI_data[ROI_separator[, 1],1],reactiveprogramdata$ROI_data[ROI_separator[, 1],2])\n    names(reactiveprogramdata$select_options)=ROI_names\n    },error=function(e) {print('Error. Please explain the issue on the Github website')})\n    })\n\n\n\n  #Spectra table.\n    output$x1 = tryCatch({DT::renderDataTable(reactiveprogramdata$spectra , selection = list(mode = 'multiple', selected = 1),server = TRUE)},error=function(e){})\n    # proxy = dataTableProxy('x1')\n\n\n\n\t#Plotly figure where to analyze peak shape fitting\n  output$plot <- renderPlotly({\n    if (reactiveprogramdata$beginning==FALSE) return()\n      reactiveprogramdata$plot\n  })\n\n\n\n  #Table where to analyze quantifications\n  output$qualitypar <- renderD3tf({\n    tryCatch({\n    tableProps =\n    d3tf(reactiveROItestingdata$qualitypar,\n      tableProps = list(btn_reset = TRUE),\n      enableTf = FALSE,\n      edit=FALSE,\n      showRowNames = TRUE,\n      tableStyle = \"table table-bordered\")\n    },error=function(e) {return(NULL) })\n\n  })\n\n  #Repository table\n  observe({\n    if (!is.na(reactiveprogramdata$imported_data))  {\n  output$repository = DT::renderDataTable(\n    reactiveprogramdata$imported_data$repository[which(reactiveprogramdata$imported_data$repository[,3]>reactiveROItestingdata$ROIpar[1,2]&reactiveprogramdata$imported_data$repository[,3]<reactiveROItestingdata$ROIpar[1,1]),] , server = TRUE)\n    }\n  })\n  observe({\n    if (!is.na(reactiveprogramdata$imported_data))  {\n      output$repository2 = DT::renderDataTable(\n        # reactiveprogramdata$imported_data$repository[which(reactiveprogramdata$imported_data$repository[,3]>(reactiveprogramdata$ROI_data_check[input$roi_profiles_select,6]-0.05)&reactiveprogramdata$imported_data$repository[,3]<(reactiveprogramdata$ROI_data_check[input$roi_profiles_select,6]+0.05)),] , server = TRUE)\n      reactiveprogramdata$imported_data$repository , selection = list(mode = 'single', selected = NULL),filter='top', server = TRUE)\n\n      }\n  })\n\n\n  #Direct edition of parameters before quantification\n  output$directedition <- renderD3tf({\n    observe({\n      if(is.null(input$directedition_edit)|(reactiveprogramdata$stop2==1)) {\n        reactiveprogramdata$change2=0\n        return(NULL)\n      }\n      edit <- input$directedition_edit\n      isolate({\n        id <- edit$id\n        row <- as.integer(edit$row)\n        col <- as.integer(edit$col)\n        val <- as.numeric(edit$val)\n        if(col == 0) {\n          oldval <- rownames(reactiveROItestingdata$signpar)[row]\n        } else if (col %in% c(1:7)){\n          if(is.na(suppressWarnings(as.numeric(val)))) {\n            oldval <- reactiveROItestingdata$signpar[row, col]\n            rejectEdit(session, tbl = \"directedition_edit\", row = row, col = col, id = id, value = oldval)\n            # reactiveprogramdata$roi=0\n            return(NULL)\n          }\n        }\n        if (reactiveprogramdata$change2==1){\n          reactiveprogramdata$change2=0\n          reactiveprogramdata$stop2=1\n        } else {\n          reactiveROItestingdata$signpar[row, col] <- val\n          confirmEdit(session, tbl = \"directedition_edit\", row = row, col = col, id = id, value = round(val,4))\n        }\n      })\n    })\n    d3tf(reactiveROItestingdata$signpar,\n         tableProps = list(btn_reset = TRUE),\n         enableTf = F,\n         edit=TRUE,\n         showRowNames = TRUE,\n         tableStyle = \"table table-bordered\")\n  })\n\n  #Quantification after direct edition of paramters\n  observeEvent(input$direct_edition, {\n    if (all(is.na(reactiveROItestingdata$signpar))) {\n      print(\"You can only perform direct edition of line shape fitted ROIs\")\n      return(NULL)\n    }\n    tryCatch({\n    reactivequantdata$method1=signals_int(reactiveprogramdata$imported_data, reactiveprogramdata$final_output,reactiveprogramdata$ind,reactiveROItestingdata$signpar,reactiveROItestingdata$ROIpar)\n    reactiveprogramdata$plot=reactivequantdata$method1$p\n    #reactivequantdata$stop3=1\n    reactiveROItestingdata$qualitypar=cbind(reactivequantdata$method1$results_to_save$quantification,reactivequantdata$method1$results_to_save$fitting_error,reactivequantdata$method1$results_to_save$signal_area_ratio)\n    colnames(reactiveROItestingdata$qualitypar)=c('Quantification','Fitting Error','Signal/total area ratio')\n    rownames(reactiveROItestingdata$qualitypar)=rownames(reactivequantdata$method1$plot_data)[4:(3+nrow(reactiveROItestingdata$qualitypar))]\n    # ind=which(rownames(reactiveROItestingdata$qualitypar)=='additional signal')\n    # reactiveprogramdata$bgColScales = rep(c(\"\",\"info\"),times=c(length(rownames(reactiveROItestingdata$qualitypar))-length(ind),length(ind)))\n    if (!is.null(reactivequantdata$method1$signals_parameters)) reactiveROItestingdata$signpar <- t(reactivequantdata$method1$signals_parameters)\n  },error=function(e) {\n    print(\"Prepare a valid input\")\n  })\n })\n\n\n\n  #2D plot\n  output$jres_plot <- renderUI({\n    if(is.na(reactiveprogramdata$jres_plot)) return()\n    plotlyOutput(\"jres_plot2\",height='250px')\n  })\n  output$jres_plot2 <- renderPlotly({\n    print(reactiveprogramdata$jres_plot)\n  })\n\n\n\n\n  ## THIRD TAB REACTIVE OUTPUTS\n\n  #Creation of table to check quantifications with the parameter chosen by the user\n  observe({\n    if (reactiveprogramdata$beginning==FALSE) return()\n    tryCatch({\n    validation_data=validation(reactiveprogramdata$final_output,input$select_validation,reactiveprogramdata$ROI_data,reactiveprogramdata$imported_data$Metadata)\n    output$fit_selection = DT::renderDataTable({ datatable(round(validation_data$alarmmatrix,4),selection = list(mode = 'single', target = 'cell')) %>% formatStyle(colnames(validation_data$alarmmatrix), backgroundColor = styleInterval(validation_data$brks, validation_data$clrs))\n    })},error=function(e) {\n      print(\"Not enough data to model it.\")\n    })\n  })\n\n  #Loading of quantification\n  observeEvent(input$fit_selection_cell_clicked, {\nif (length(input$fit_selection_cell_clicked)<1) return()\n    #Checks and setting of parameters\n    tryCatch({reactiveprogramdata$info=input$fit_selection_cell_clicked\n    reactiveprogramdata$ind=reactiveprogramdata$info$row\n    reactiveprogramdata$change=reactiveprogramdata$change2=1\n    reactiveprogramdata$stop=reactiveprogramdata$stop2=0\n    # proxy %>% selectRows(as.numeric(input$fit_selection_cell_clicked$col+2))\n    #if (length(reactiveprogramdata$info$row)>0) reactivequantdata$stop3=1\n    resetInput(session, \"ROIdata_edit\")\n    resetInput(session, \"directedition_edit\")\n    updateSelectInput(session, \"select\",selected = NULL)\n\n    # if (length(reactiveprogramdata$info$row)!=1) return(NULL)\n\n    dummy=load_quantification(reactiveprogramdata$useful_data,reactiveprogramdata$imported_data,reactiveprogramdata$final_output,reactiveprogramdata$info,reactiveprogramdata$ROI_data)\n    #updateSelectInput(session, \"select\",choices = reactiveprogramdata$select_options,selected = dummy$ind)\n\n      reactiveprogramdata$plot=dummy$plot\n      reactiveROItestingdata$signpar=dummy$signpar\n      reactiveROItestingdata$ROIpar=dummy$ROIpar\n      reactiveROItestingdata$qualitypar=dummy$qualitypar\n\n    #Redirect to quantification tab\n    updateTabsetPanel(session, \"mynavlist\",selected = \"Individual Quantification\")\n    },error=function(e) {\n      print(\"Select a valid quantification.\")\n    })\n  })\n\n\n  ## FOURTH TAB REACTIVE OUTPUTS\n\n\n  observeEvent(input$roi_profile_option, {\n  tryCatch({\n      output$roi_profiles_plot=renderPlotly({\n        if (input$roi_profile_option==1) {\n          reactiveprogramdata$clusterplot\n          } else if (input$roi_profile_option==2) {\n            reactiveprogramdata$medianplot\n            }\n        })\n  },error=function(e) {print('Error. Please explain the issue on the Github website')})\n\n\n    })\n\n  #Add and remove signals and save changes\n  observeEvent(input$add_hmdb_signal, {\n    dummy=reactiveprogramdata$imported_data$repository[input$repository2_rows_selected,]\n    dummy=c(dummy[,3]+0.02,dummy[,3]-0.02,'Baseline Fitting',dummy[,1],1,dummy[,3],0.005,median(reactiveprogramdata$ROI_data_check[,8]),dummy[,4],dummy[,5],0,dummy[,6])\n    if (dummy[9]=='d') {\n      dummy[9]=2\n    } else if (dummy[9]=='t') {\n      dummy[9]=3\n    } else {\n      dummy[9]=1\n    }\n\n    if (is.na(as.numeric(dummy[10])))  dummy[10]=0\n    dummy=as.list(dummy)\n    dummy[-c(3,4)]=as.numeric(dummy[-c(3,4)])\n\n    reactiveprogramdata$ROI_data_check=rbind(dummy,reactiveprogramdata$ROI_data_check)\n  })\n  observeEvent(input$open_hmdb_url, {\n    tryCatch({\n      browseURL(paste(\"http://www.hmdb.ca/metabolites/\",reactiveprogramdata$imported_data$repository[input$repository2_rows_selected,2],\"#spectra\",sep=''))    }, error = function(e) {\n      print('Not possible to load HMDB url.')\n    })\n  })\n  observeEvent(input$add_signal, {\n    tryCatch({\n    reactiveprogramdata$ROI_data_check=rbind(rep(NA,ncol(reactiveprogramdata$ROI_data_check)),reactiveprogramdata$ROI_data_check)\n    }, error = function(e) {\n      print('Error. Please explain the issue in the Github page.')\n    })\n     })\n  observeEvent(input$remove_signal, {\n    tryCatch({\n    reactiveprogramdata$ROI_data_check=reactiveprogramdata$ROI_data_check[-input$roi_profiles_select,]\n    resetInput(session, \"roi_profiles_edit\")\n    }, error = function(e) {\n      print('Error. Please explain the issue in the Github page.')\n    })\n     })\n  observeEvent(input$save_changes, {\n    tryCatch({\n      reactiveprogramdata$ROI_data_check=reactiveprogramdata$ROI_data_check[!duplicated(reactiveprogramdata$ROI_data_check[,4:5]),]\n\n      reactiveprogramdata$ROI_data_check=reactiveprogramdata$ROI_data_check[sort(reactiveprogramdata$ROI_data_check[,1],index.return=TRUE)$ix,]\n    new_fitting_error=new_intensity=new_signal_area_ratio=new_shift=new_width=new_Area=matrix(NA,nrow(reactiveprogramdata$final_output$signal_area_ratio),nrow(reactiveprogramdata$ROI_data_check),dimnames=list(reactiveprogramdata$imported_data$Experiments,paste(reactiveprogramdata$ROI_data_check[,4],reactiveprogramdata$ROI_data_check[,5],sep='_')))\n    new_signals_codes=new_signals_names=rep(NA,nrow(reactiveprogramdata$ROI_data_check))\n    new_useful_data=reactiveprogramdata$useful_data\n    for (i in 1:length(new_useful_data)) new_useful_data[[i]]=vector(\"list\", nrow(reactiveprogramdata$ROI_data_check))\n    for (i in 1:nrow(reactiveprogramdata$ROI_data_check)) {\n      ind=which(reactiveprogramdata$ROI_data[,4]==reactiveprogramdata$ROI_data_check[i,4]&reactiveprogramdata$ROI_data[,5]==reactiveprogramdata$ROI_data_check[i,5])\n      if (length(ind)>0) {\n        new_fitting_error[,i]=reactiveprogramdata$final_output$fitting_error[,ind]\n        new_intensity[,i]=reactiveprogramdata$final_output$intensity[,ind]\n        new_signal_area_ratio[,i]=reactiveprogramdata$final_output$signal_area_ratio[,ind]\n        new_shift[,i]=reactiveprogramdata$final_output$shift[,ind]\n        new_width[,i]=reactiveprogramdata$final_output$half_band_width[,ind]\n        new_Area[,i]=reactiveprogramdata$final_output$quantification[,ind]\n        for (j in 1:length(new_useful_data)) new_useful_data[[j]][[i]]=reactiveprogramdata$useful_data[[j]][[ind]]\n      }\n    }\n    reactiveprogramdata$final_output$fitting_error=new_fitting_error\n    reactiveprogramdata$final_output$intensity=new_intensity\n    reactiveprogramdata$final_output$signal_area_ratio=new_signal_area_ratio\n    reactiveprogramdata$final_output$shift=new_shift\n    reactiveprogramdata$final_output$half_band_width=new_width\n    reactiveprogramdata$final_output$quantification=new_Area\n    reactiveprogramdata$useful_data=new_useful_data\n    reactiveprogramdata$ROI_data=reactiveprogramdata$ROI_data_check\n    reactiveprogramdata$imported_data$signals_codes=seq(nrow(reactiveprogramdata$ROI_data))\n    reactiveprogramdata$imported_data$signals_names=paste(reactiveprogramdata$ROI_data[,4],reactiveprogramdata$ROI_data[,5],sep='_')\n\n    dummy = which(is.na(reactiveprogramdata$ROI_data[, 1]))\n    if (length(dummy)==0) dummy=dim(reactiveprogramdata$ROI_data)[1]+1\n    lal=which(duplicated(reactiveprogramdata$ROI_data[-dummy,1:2])==FALSE)\n    ROI_separator = cbind(lal, c(lal[-1] - 1, dim(reactiveprogramdata$ROI_data[-dummy,])[1]))\n    ROI_names=paste(reactiveprogramdata$ROI_data[ROI_separator[, 1],1],reactiveprogramdata$ROI_data[ROI_separator[, 1],2])\n    reactiveprogramdata$select_options=1:length(ROI_names)\n    names(reactiveprogramdata$select_options)=ROI_names\n    updateSelectInput(session, \"select\",\n      choices = reactiveprogramdata$select_options,selected = input$x1_rows_selected\n    )\n    }, error = function(e) {\n      print('Problem during update of data. Please explain the issue in the Github page.')\n})\n  })\n\n  #ROI Profiles table\n  output$roi_profiles <- renderD3tf({\n    observe({\n      edit <- input$roi_profiles_edit\n      if (!is.null(edit)) {\n        isolate({\n          id <- edit$id\n          row <- as.integer(edit$row)\n          col <- as.integer(edit$col)\n          val <- edit$val\n\n          if(col == 0) {\n            oldval <- rownames(reactiveprogramdata$ROI_data_check)[row]\n          } else if (col %in% c(1:2,5:12)){\n            # numeric columns\n            if(is.na(suppressWarnings(as.numeric(val)))) {\n              oldval <- reactiveprogramdata$ROI_data_check[row, col]\n              rejectEdit(session, tbl = \"roi_profiles\", row = row, col = col, id = id, value = oldval)\n              #    reactiveprogramdata$roi=0\n              return(NULL)\n            }\n          } else if (col %in% c(3,4)) {\n            if(is.na(suppressWarnings(val))) {\n              oldval <- reactiveprogramdata$ROI_data_check[row, col]\n              rejectEdit(session, tbl = \"roi_profiles\", row = row, col = col, id = id, value = oldval)\n              return(NULL)\n            }\n          }\n\n          if (reactiveprogramdata$change==1){\n            reactiveprogramdata$change=0\n            reactiveprogramdata$stop=1\n            disableEdit(session, \"roi_profiles\", c(1:12))\n          } else{\n            if(col == 0) {\n            } else if (col %in% c(1:2,5:12)) {\n              reactiveprogramdata$ROI_data_check[row, col] <- as.numeric(val)\n              #    reactiveprogramdata$roi=1\n            } else if (col %in% c(3,4)) {\n              reactiveprogramdata$ROI_data_check[row, col] <- val\n            }\n            confirmEdit(session, tbl = \"roi_profiles\", row = row, col = col, id = id, value = val)\n          }\n        })\n      }\n    })\n\n    d3tf(reactiveprogramdata$ROI_data_check,\n      tableProps = list(btn_reset = FALSE),\n      enableTf = FALSE,\n      edit=TRUE,\n      selectableRows = \"single\",\n      tableStyle = \"table table-bordered\")\n\n  })\n\n  ## FIFTH TAB REACTIVE OUTPUTS\n\n  #Boxplot plot\n  output$plot_p_value_2 <- renderPlotly({\n    if(all(is.na(reactiveprogramdata$final_output$quantification))) return()\n    tryCatch({type_analysis_plot(reactiveprogramdata$final_output$quantification,reactiveprogramdata$final_output,reactiveprogramdata$imported_data,type='boxplot')\n    }, error = function(e) {\n      print('Error. Please explain the issue in the Github page.')\n      return(NULL)\n    })\n  })\n  #PCA plot\n  output$pcascores <- renderPlotly({\n    if(all(is.na(reactiveprogramdata$final_output$quantification))) return()\n\n    tryCatch({type_analysis_plot(reactiveprogramdata$final_output$quantification,reactiveprogramdata$final_output,reactiveprogramdata$imported_data,type='pca')\n  }, error = function(e) {\n    print('Generation of Regions of Interest not possible. Please explain the issue in the Github page.')\n    return(NULL)\n  })\n  })\n\n  ## SIXTH TAB REACTIVE OUTPUTS\n\n# STOCSY generation\n  observeEvent(input$stocsy, {\n  tryCatch({\n    left_ppm <- renderText({ input$left_ppm })\n    right_ppm <- renderText({ input$right_ppm })\n      output$stocsy_plot=renderPlotly({\n        if (input$stocsy==1) {\n          type_plot(reactiveprogramdata$imported_data,rev(range(reactiveprogramdata$imported_data$ppm)),1,reactiveprogramdata$medianplot,reactiveprogramdata$clusterplot)\n        } else {\n        STOCSY(reactiveprogramdata$imported_data$dataset,reactiveprogramdata$imported_data$ppm,c(input$left_ppm,input$right_ppm),input$correlation_method)\n          }\n        })\n  },error=function(e) {return(NULL) })\n    })\n\n\n\n  #Dengrogran heatmaps for quantification and chemical shift\n  tryCatch(output$dendheatmapareadata <- renderPlotly({\n    if(all(is.na(reactiveprogramdata$final_output$quantification))) return()\n\n    tryCatch({type_analysis_plot(reactiveprogramdata$final_output$quantification,reactiveprogramdata$final_output,reactiveprogramdata$imported_data,type='dendrogram_heatmap')\n  }, error = function(e) {\n    print('Error. Please explain the issue in the Github page.')\n    return(NULL)\n  })\n  }))\n\n  tryCatch(output$dendheatmapshiftdata <- renderPlotly({\n    if(all(is.na(reactiveprogramdata$final_output$quantification))) return()\n\n    tryCatch({type_analysis_plot(reactiveprogramdata$final_output$shift,reactiveprogramdata$final_output,reactiveprogramdata$imported_data,type='dendrogram_heatmap')\n  }, error = function(e) {\n    print('Error. Please explain the issue in the Github page.')\n    return(NULL)\n  })\n}))\n\n\n\n}\n",
    "created" : 1493569234602.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2115453248",
    "id" : "5855CB44",
    "lastKnownWriteTime" : 1493573774,
    "last_content_update" : 1493573774864,
    "path" : "~/GitHub/rDolphin/inst/app/server.R",
    "project_path" : "inst/app/server.R",
    "properties" : {
    },
    "relative_order" : 7,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}