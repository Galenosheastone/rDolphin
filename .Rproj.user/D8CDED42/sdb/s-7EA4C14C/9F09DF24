{
    "collab_server" : "",
    "contents" : "\n#' Automatic quantification of signals for all experiments using the information located in the ROI patterns file.\n#'\n#' @param imported_data List with typical elements necessary to perform quantification of ROIs.\n#' @param final_output List with quantifications and indicators of quality of quantification.\n#' @param useful_data List with necessary information to load quantifications on the Shiny GUI.\n#' @param ROI_data ROIs data.\n#'\n#' @return List with updated final_output and useful_data variables.\n#' @export autorun\n#' @import baseline\n#'\n#' @examples\n#' setwd(paste(system.file(package = \"rDolphin\"),\"extdata\",sep='/'))\n#' imported_data=import_data(\"Parameters_MTBLS242_15spectra_5groups.csv\")\n#' quantification_variables=autorun(imported_data,imported_data$final_output,imported_data$useful_data,imported_data$ROI_data)\n\n\nautorun = function(imported_data, final_output,useful_data,ROI_data) {\n\n  print('Be patient. Gonna take a while. You should be writing, meanwhile.')\n\n  #Splitting of ROI data into individual ROIs to be quantified\n\tdummy = which(is.na(ROI_data[, 1]))\n    if (length(dummy)==0) dummy=dim(ROI_data)[1]+1\n    lal=which(duplicated(ROI_data[-dummy,1:2])==F)\n    ROI_separator = cbind(lal, c(lal[-1] - 1, dim(ROI_data[-dummy,])[1]))\n\n  baselinedataset=baseline.rollingBall(imported_data$dataset,5,5)$baseline\n\n  #For every ROI\n  for (ROI_index in seq_along(ROI_separator[, 1])) {\n\n    #Preparation of ROI parameters\n    ROI_profile = ROI_data[ROI_separator[ROI_index, 1]:ROI_separator[ROI_index, 2],]\n    ROI_buckets = which.min(abs(as.numeric(ROI_profile[1, 1])-imported_data$ppm)):which.min(abs(as.numeric(ROI_profile[1, 2])-imported_data$ppm))\n    if (length(ROI_buckets)<5) next\n    if (ROI_buckets[1]>ROI_buckets[2]) ROI_buckets=rev(ROI_buckets)\n    Xdata = imported_data$ppm[ROI_buckets]\n    fitting_type = as.character(ROI_profile[1, 3])\n\tsignals_to_quantify = which(ROI_profile[, 5] >= 1)\n\tsignals_codes = (ROI_separator[ROI_index, 1]:ROI_separator[ROI_index, 2])[signals_to_quantify]\n\n\n    print(paste(ROI_profile[1,1], ROI_profile[1,2], sep = '-'))\n    print(paste('ROI',ROI_index,'of',nrow(ROI_separator)))\n\n      #Preparation of program parameters to be sued during fitting, with some variables added to ease interpretability of code\n      program_parameters=imported_data$program_parameters\n      program_parameters$freq = imported_data$freq\n      program_parameters$ROI_buckets = ROI_buckets\n      program_parameters$buck_step = imported_data$buck_step\n\n\n    #Quantification for every spectrum\n    pb   <- txtProgressBar(1, nrow(imported_data$dataset), style=3)\n    for (spectrum_index in 1:nrow(imported_data$dataset)) {\n\n      #Preparation of necessary variables to store figures and information of the fitting\n      Ydata = as.numeric(imported_data$dataset[spectrum_index, ROI_buckets])\n      #If the quantification is through integration with or without baseline\n      if (fitting_type == \"Clean Sum\" ||\n          fitting_type == \"Baseline Sum\") {\n        #Fitting error is calculated through the comparison with the median spectrum, so singals interfering with the integration can be controlled\n        Ydatamedian=as.numeric(apply(imported_data$dataset[, ROI_buckets,drop=F],2,median))\n\n        clean_fit = ifelse(fitting_type == \"Clean Sum\", \"Y\", \"N\")\n        dummy = integration(clean_fit, Xdata,Ydata,Ydatamedian)\n        results_to_save=dummy$results_to_save\n\n        #Generation of useful variables specific of every quantification\n        useful_data[[spectrum_index]][[signals_codes]]$ROI_profile=ROI_profile\n        useful_data[[spectrum_index]][[signals_codes]]$plot_data=dummy$plot_data\n        useful_data[[spectrum_index]][[signals_codes]]$Xdata=Xdata\n        useful_data[[spectrum_index]][[signals_codes]]$Ydata=Ydata\n        useful_data[[spectrum_index]][[signals_codes]]$results_to_save=results_to_save\n        useful_data[[spectrum_index]][[signals_codes]]$error1=results_to_save$fitting_error\n\n        #If the quantification is through fitting with or without baseline\n      } else if (fitting_type == \"Clean Fitting\" || fitting_type ==\n          \"Baseline Fitting\") {\n\n        program_parameters$clean_fit = ifelse(fitting_type == \"Clean Fitting\", \"Y\",\n          \"N\")\n\n        #Adaptation of the info of the parameters into a single matrix and preparation (if necessary) of the background signals that will conform the baseline\n        FeaturesMatrix = fitting_prep(Xdata,\n          Ydata,\n          ROI_profile[, 5:11,drop=F],\n          program_parameters,baselinedataset[spectrum_index,ROI_buckets])\n\n        #Calculation of the parameters that will achieve the best fitting\n        dummy = fittingloop(FeaturesMatrix,\n          Xdata,\n          Ydata,\n          program_parameters)\n        signals_parameters=dummy$signals_parameters\n\n        #Fitting of the signals\n        multiplicities=c(FeaturesMatrix[,11],rep(1,(length(signals_parameters)/5)-dim(FeaturesMatrix)[1]))\n        roof_effect=c(FeaturesMatrix[,12],rep(0,(length(signals_parameters)/5)-dim(FeaturesMatrix)[1]))\n        fitted_signals = signal_fitting(signals_parameters,\n          Xdata,multiplicities,roof_effect,Ydata,program_parameters$freq)\n               dim(signals_parameters) = c(5, length(signals_parameters)/5)\n        rownames(signals_parameters) = c('intensity','shift','half_band_width','gaussian','J_coupling')\n        signals_parameters=rbind(signals_parameters,multiplicities,roof_effect)\n\n        #Generation of output data about the fitting and of the necessary variables for the generation ofa figure\n        dummy = output_generator(signals_to_quantify,fitted_signals,Ydata,Xdata,signals_parameters,multiplicities)\n        output_data=dummy$output_data\n        error1=ifelse(is.nan(dummy$error1),3000,dummy$error1)\n\n        #If any of the qunatificaitons has more than 5% fitting error, try again the deconvolution\n        if (any(output_data$fitting_error>0.05)==T) {\n        dummy = fittingloop(FeaturesMatrix,Xdata,Ydata,program_parameters)\n        signals_parameters=dummy$signals_parameters\n\n\t\t#Fitting of the signals\n        multiplicities=c(FeaturesMatrix[,11],rep(1,(length(signals_parameters)/5)-dim(FeaturesMatrix)[1]))\n        roof_effect=c(FeaturesMatrix[,12],rep(0,(length(signals_parameters)/5)-dim(FeaturesMatrix)[1]))\n        fitted_signals = signal_fitting(signals_parameters,\n          Xdata,multiplicities,roof_effect,Ydata,program_parameters$freq)\n        dim(signals_parameters) = c(5, length(signals_parameters)/5)\n\t\tsignals_parameters=rbind(signals_parameters,multiplicities,roof_effect)\n        rownames(signals_parameters) = c('intensity','shift','half_band_width','gaussian','J_coupling','multiplicities','roof effect')\n        if (fitting_type == \"Clean Fitting\") {\n          colnames(signals_parameters)=paste(ROI_profile[,4],ROI_profile[,5],sep='_')\n        } else {\n          colnames(signals_parameters)=c(paste(ROI_profile[,4],ROI_profile[,5],sep='_'),paste('baseline_signal',seq(ncol(signals_parameters)-nrow(ROI_profile)),sep='_'))\n        }\n        #Generation of output data about the fitting and of the necessary variables for the generation ofa figure\n        dummy = output_generator(signals_to_quantify,fitted_signals,Ydata,Xdata,signals_parameters,multiplicities)\n\n        #If new deconvolution has improved previous one\n        if (dummy$error1<error1) {\n          output_data=dummy$output_data\n          error1=dummy$error1\n        }}\n\n        #Generation of the dataframe with the final output variables\n        results_to_save = data.frame(\n          shift = output_data$shift,\n          quantification = output_data$quantification,\n          signal_area_ratio = output_data$signal_area_ratio,\n          fitting_error = output_data$fitting_error,\n          intensity = output_data$intensity,\n          half_band_width = output_data$half_band_width\n        )\n\n        #Generation of the figure data\n        plot_data = rbind(output_data$signals_sum,output_data$baseline_sum,output_data$fitted_sum,output_data$signals\n        )\n        rownames(plot_data) = c(\"signals_sum\",\"baseline_sum\",\"fitted_sum\",as.character(paste(ROI_profile[,4],ROI_profile[,5],sep='_')),rep('additional signal',dim(plot_data)[1]-length(ROI_profile[,4])-3))\n\n        #Generation of useful variables specific of every quantification\n        for (i in seq_along(signals_codes)) {\n          useful_data[[spectrum_index]][[signals_codes[i]]]$ROI_profile=ROI_profile\n          useful_data[[spectrum_index]][[signals_codes[i]]]$program_parameters=program_parameters\n          useful_data[[spectrum_index]][[signals_codes[i]]]$plot_data=plot_data\n          useful_data[[spectrum_index]][[signals_codes[i]]]$error1=error1\n          useful_data[[spectrum_index]][[signals_codes[i]]]$FeaturesMatrix=FeaturesMatrix\n          useful_data[[spectrum_index]][[signals_codes[i]]]$signals_parameters=signals_parameters\n          useful_data[[spectrum_index]][[signals_codes[i]]]$Xdata=Xdata\n          useful_data[[spectrum_index]][[signals_codes[i]]]$Ydata=Ydata\n          useful_data[[spectrum_index]][[signals_codes[i]]]$results_to_save=results_to_save\n          }\n     }\n\n      #Generation of output variables specific of every quantification\n      final_output = save_output(spectrum_index,signals_codes,results_to_save,imported_data$buck_step,final_output)\n\n      setTxtProgressBar(pb, spectrum_index)\n      }\n\n  }\n  print(\"Done!\")\n  ind=which(ROI_data[,3]==\"Clean Sum\"| ROI_data[,3]==\"Baseline Sum\")\n  if (length(ind>0)) {\n  dummy=integration_error(ROI_data,useful_data,final_output,ind)\n  final_output=dummy$final_output\n  useful_data=dummy$useful_data\n}\n  quantification_variables=list(final_output=final_output,useful_data=useful_data)\n  return(quantification_variables)\n}\n",
    "created" : 1492703100560.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2631795031",
    "id" : "9F09DF24",
    "lastKnownWriteTime" : 1492704340,
    "last_content_update" : 1492704340156,
    "path" : "~/GitHub/prova/R/autorun.R",
    "project_path" : "R/autorun.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}