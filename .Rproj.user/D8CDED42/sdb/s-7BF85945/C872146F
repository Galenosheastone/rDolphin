{
    "collab_server" : "",
    "contents" : "\n#' Quantification of individual ROIs with selected spectra.\n#'\n#' @param imported_data List with typical elements necessary to perform quantification of ROIs.\n#' @param final_output List with quantifications and indicators of quality of quantification.\n#' @param ind Experiment to quantify.\n#' @param ROI_profile Information of signals to fit in ROI\n#' @param useful_data List with necessary information to load quantifications on the Shiny GUI.\n#' @param interface Is the function being used with the Shiny GUI or not? By default F.\n#'\n#' @return Output depends on if the function is being used or not in the interface. If not in the interface, list with updated final_output and useful_data variables. If in the interface, necessary parameters to evaluate quality of the quantification before confiramtion by the user.\n#' @export not_automatic_quant\n#' @import baseline\n#'\n#' @examples\n#' setwd(paste(system.file(package = \"rDolphin\"),\"extdata\",sep='/'))\n#' imported_data=import_data(\"Parameters_MTBLS242_15spectra_5groups.csv\")\n#' resulting_data=not_automatic_quant(imported_data,imported_data$final_output,c(1,4),imported_data$ROI_data[1:2,],imported_data$useful_data)\n\n\nnot_automatic_quant = function(imported_data, final_output,ind,ROI_profile,useful_data,interface=F) {\n\n  resulting_data=list(final_output=final_output,useful_data=useful_data)\n\n  if (identical(ind,seq(nrow(imported_data$dataset)))) pb <- txtProgressBar(1, length(ind), style=3)\n\n  ROI_buckets = which.min(abs(as.numeric(ROI_profile[1, 1])-imported_data$ppm)):which.min(abs(as.numeric(ROI_profile[1, 2])-imported_data$ppm))\n  Xdata= as.numeric(imported_data$ppm[ROI_buckets])\n  program_parameters=imported_data$program_parameters\n  program_parameters$freq = imported_data$freq\n  program_parameters$ROI_buckets = ROI_buckets\n  program_parameters$buck_step = imported_data$buck_step\n  fitting_type = as.character(ROI_profile[1, 3])\n  if (length(grep(\"Clean\",fitting_type))==1) {\n    program_parameters$clean_fit=\"Y\"\n  } else {\n    program_parameters$clean_fit=\"N\"\n  }\n  signals_to_quantify = which(ROI_profile[, 5] >0)\n  signals_codes = signals_names = rep(NA,length(signals_to_quantify))\n  j = 1\n  for (i in signals_to_quantify) {\n    k = which(imported_data$signals_names == paste(ROI_profile[i,\n      4],ROI_profile[i,5],sep='_'))\n\n    signals_codes[j] = imported_data$signals_codes[k]\n    signals_names[j] = as.character(imported_data$signals_names[k])\n    j = j + 1\n  }\n\n  for (spectrum_index in ind) {\n    dummy=imported_data$dataset[spectrum_index,(ROI_buckets[1]-5):(ROI_buckets[length(ROI_buckets)]+5)]\n    baseline=baseline.rollingBall(rbind(dummy,dummy),5,5)$baseline[1,]\n    baseline=baseline[6:(5+length(ROI_buckets))]\n    # print(paste(\"Spectrum \",spectrum_index))\n\n    Ydata = as.numeric(imported_data$dataset[spectrum_index, ROI_buckets])\n\n    experiment_name = imported_data$Experiments[[spectrum_index]]\n\n    # If the quantification is through integration with or without baseline\n    if (fitting_type == \"Clean Sum\" ||\n        fitting_type == \"Baseline Sum\") {\n      # program_parameters$clean_fit = ifelse(fitting_type == \"Clean Sum\", \"Y\",\n      #                                       \"N\")\n      # program_parameters$freq=imported_data$freq\n      # baseline_int = fitting_prep_integration(Xdata,Ydata,program_parameters,baseline)\n      # Ydatamedian=as.numeric(apply(imported_data$dataset[, ROI_buckets,drop=F],2,median))\n\n     dummy = integration(program_parameters$clean_fit, Xdata,Ydata,interface='T')\n\n      results_to_save=dummy$results_to_save\n      p=dummy$p\n      plot_data=dummy$plot_data\n\n      # resulting_data$integration_parameters=integration_parameters\n      #Generation of output variables specific of every quantification\n\tif (identical(ind,seq(nrow(imported_data$dataset)))) {\n        resulting_data$useful_data[[spectrum_index]][[signals_codes]]$ROI_profile=ROI_profile\n        # resulting_data$useful_data[[spectrum_index]][[signals_codes]]$integration_parameters=integration_parameters\n        resulting_data$useful_data[[spectrum_index]][[signals_codes]]$plot_data=dummy$plot_data\n        resulting_data$useful_data[[spectrum_index]][[signals_codes]]$Xdata=Xdata\n        resulting_data$useful_data[[spectrum_index]][[signals_codes]]$Ydata=Ydata\n        resulting_data$useful_data[[spectrum_index]][[signals_codes]]$results_to_save=results_to_save\n        resulting_data$useful_data[[spectrum_index]][[signals_codes]]$error1=results_to_save$fitting_error\n\n        final_output = save_output(\n          spectrum_index,\n          signals_codes,\n          results_to_save,\n          imported_data$buck_step,\n          final_output\n        )\n\n      }\n\n      #If the quantification is through fitting with or without baseline\n    } else if (fitting_type == \"Clean Fitting\" || fitting_type ==\n               \"Baseline Fitting\") {\n\n      program_parameters$freq=imported_data$freq\n\n      FeaturesMatrix = fitting_prep(Xdata,\n                                    Ydata,\n                                    ROI_profile[, 5:11,drop=F],\n                                    program_parameters,baseline)\n      #Calculation of the parameters that will achieve the best fitting\n      dummy = fittingloop(FeaturesMatrix,\n                                       Xdata,\n                                       Ydata,\n                                       program_parameters)\n      signals_parameters=dummy$signals_parameters\n      multiplicities=c(FeaturesMatrix[,11],rep(1,(length(signals_parameters)/5)-dim(FeaturesMatrix)[1]))\n      roof_effect=c(FeaturesMatrix[,12],rep(0,(length(signals_parameters)/5)-dim(FeaturesMatrix)[1]))\n\n      signals_parameters_2=signals_parameters\n      multiplicities_2=multiplicities\n      roof_effect_2=roof_effect\n      #Fitting of the signals\n      dim(signals_parameters) = c(5, length(signals_parameters)/5)\n      rownames(signals_parameters) = c(\n        'intensity',\n        'shift',\n        'half_band_width',\n        'gaussian',\n        'J_coupling'\n      )\n\n      Xdata_2=imported_data$ppm\n\t   program_parameters$signals_to_quantify=signals_to_quantify\n      Ydata_2 = as.numeric(imported_data$dataset[spectrum_index, ])\n      # signals_parameters_2=unlist(signals_parameters_2)\n      # multiplicities_2=unlist(multiplicities_2)\n      # roof_effect_2=unlist(roof_effect_2)\n      # signals_parameters_2=unlist(signals_parameters)\n      multiplicities_2=unlist(multiplicities)\n      roof_effect_2=unlist(roof_effect)\n\n      fitted_signals = signal_fitting(signals_parameters_2,\n                                         Xdata_2,multiplicities_2,roof_effect_2,program_parameters$freq)\n      # signals_parameters=as.matrix(signals_parameters)\n\n      # dim(signals_parameters_2) = c(5, length(signals_parameters_2)/5)\n      # rownames(signals_parameters_2) = c(\n      #   'intensity',\n      #   'shift',\n      #   'half_band_width',\n      #   'gaussian',\n      #   'J_coupling'\n      # )\n\n\n      #Generation of output data about the fitting and of the necessary variables for the generation ofa figure\n      dummy = output_generator(\n        signals_to_quantify,\n        fitted_signals,\n        Ydata_2,\n        Xdata_2,\n        signals_parameters,multiplicities,ROI_buckets\n      )\n      output_data=dummy$output_data\n      error1=dummy$error1\n\n      if (any(output_data$fitting_error>0.05)==T) {\n        dummy = fittingloop(FeaturesMatrix,\n          Xdata,\n          Ydata,\n          program_parameters)\n        signals_parameters=dummy$signals_parameters\n        multiplicities=c(FeaturesMatrix[,11],rep(1,(length(signals_parameters)/5)-dim(FeaturesMatrix)[1]))\n        roof_effect=c(FeaturesMatrix[,12],rep(0,(length(signals_parameters)/5)-dim(FeaturesMatrix)[1]))\n\n        signals_parameters_2=signals_parameters\n        # multiplicities_2=multiplicities\n        # roof_effect_2=roof_effect\n        #Fitting of the signals\n        dim(signals_parameters) = c(5, length(signals_parameters)/5)\n        rownames(signals_parameters) = c(\n          'intensity',\n          'shift',\n          'half_band_width',\n          'gaussian',\n          'J_coupling'\n        )\n\n        # signals_parameters_2=unlist(signals_parameters_2)\n        # multiplicities_2=unlist(multiplicities_2)\n        # roof_effect_2=unlist(roof_effect_2)\n        # signals_parameters_2=unlist(signals_parameters)\n        multiplicities_2=unlist(multiplicities)\n        roof_effect_2=unlist(roof_effect)\n\n        fitted_signals = signal_fitting(signals_parameters_2,\n          Xdata_2,multiplicities_2,roof_effect_2,program_parameters$freq)\n        # signals_parameters=as.matrix(signals_parameters)\n\n        # dim(signals_parameters_2) = c(5, length(signals_parameters_2)/5)\n        # rownames(signals_parameters_2) = c(\n        #   'intensity',\n        #   'shift',\n        #   'half_band_width',\n        #   'gaussian',\n        #   'J_coupling'\n        # )\n\n        #Generation of output data about the fitting and of the necessary variables for the generation ofa figure\n        dummy = output_generator(\n          signals_to_quantify,\n          fitted_signals,\n          Ydata_2,\n          Xdata_2,\n          signals_parameters,multiplicities,ROI_buckets\n        )\n\n        #If new deconvolution has improved previous one\n        if (dummy$error1<error1) {\n          output_data=dummy$output_data\n          error1=dummy$error1\n        }}\n\n      #Generation of the dataframe with the final output variables\n      results_to_save = data.frame(\n        shift = output_data$shift,\n        quantification = output_data$quantification,\n        signal_area_ratio = output_data$signal_area_ratio,\n        fitting_error = output_data$fitting_error,\n        intensity = output_data$intensity,\n        half_band_width = output_data$half_band_width\n      )\n\n      plot_data = rbind(\n        output_data$signals_sum,\n        output_data$baseline_sum,\n        output_data$fitted_sum,\n        output_data$signals\n      )\n      rownames(plot_data) = c(\"signals_sum\",\n        \"baseline_sum\",\n        \"fitted_sum\",\n        as.character(paste(ROI_profile[,4],ROI_profile[,5],sep='_')),rep('additional signal',dim(plot_data)[1]-length(ROI_profile[,4])-3))\n\n      plotdata2 = data.frame(Xdata=Xdata_2,\n        Ydata=Ydata_2,\n        plot_data[3, ],\n        plot_data[2, ] )\n      plotdata3 <- melt(plotdata2, id = \"Xdata\")\n      plotdata3$variable = c(\n        rep('Original Spectrum', length(Ydata_2)),\n        rep('Generated Spectrum', length(Ydata_2)),\n        rep('Generated Background', length(Ydata_2))\n      )\n      plot_title = paste(imported_data$Experiments[spectrum_index],\"- ROI \",ROI_profile[1,1],\"-\",ROI_profile[1,2],\"ppm\")\ncolors=c(I('red'),I('blue'),I('black'),I('brown'),I('cyan'),I('green'),I('yellow'))\n      p=plot_ly(plotdata3,x=~Xdata,y=~value,color=~variable,type='scatter',mode='lines',fill=NULL) %>% layout(title = plot_title,xaxis = list(range=c(Xdata[1],Xdata[length(Xdata)]),title = 'ppm'), yaxis = list(range=c(0,max(Ydata)),title = 'Intensity'))\n        for (i in 4:nrow(plot_data)) {\n          plotdata5 =  data.frame(Xdata=Xdata_2, variable=rownames(plot_data)[i] ,value=plot_data[i,])\n\n        p=p %>%add_trace(data=plotdata5,x=~Xdata,y=~value,name=~variable,type='scatter',mode='lines',fill='tozeroy',fillcolor=colors[i-3])\n}\n\n\n    signals_parameters=rbind(signals_parameters,multiplicities,roof_effect)\n    if (fitting_type == \"Clean Fitting\") {\n      colnames(signals_parameters)=paste(ROI_profile[,4],ROI_profile[,5],sep='_')\n    } else {\n      colnames(signals_parameters)=c(paste(ROI_profile[,4],ROI_profile[,5],sep='_'),paste('baseline_signal',seq(ncol(signals_parameters)-nrow(ROI_profile)),sep='_'))\n    }\n\n    # if (resulting_data$useful_data[[spectrum_index]][[signals_codes[1]]]$error1>0.8*error1) {\n\n    # }\nif (identical(ind,seq(nrow(imported_data$dataset)))| interface ==F)  {\n\t# if (resulting_data$useful_data[[spectrum_index]][[signals_codes[1]]]$error1>error1) {\n      for (i in seq_along(signals_codes)) {\n        resulting_data$useful_data[[spectrum_index]][[signals_codes[i]]]$ROI_profile=ROI_profile\n        resulting_data$useful_data[[spectrum_index]][[signals_codes[i]]]$program_parameters=program_parameters\n        resulting_data$useful_data[[spectrum_index]][[signals_codes[i]]]$plot_data=plot_data[,ROI_buckets]\n        resulting_data$useful_data[[spectrum_index]][[signals_codes[i]]]$FeaturesMatrix=FeaturesMatrix\n        resulting_data$useful_data[[spectrum_index]][[signals_codes[i]]]$signals_parameters=signals_parameters\n        resulting_data$useful_data[[spectrum_index]][[signals_codes[i]]]$error1=error1\n        resulting_data$useful_data[[spectrum_index]][[signals_codes[i]]]$Xdata=Xdata\n        resulting_data$useful_data[[spectrum_index]][[signals_codes[i]]]$Ydata=Ydata\n        resulting_data$useful_data[[spectrum_index]][[signals_codes[i]]]$results_to_save=results_to_save\n\n\n      }\n        resulting_data$final_output = save_output(\n          spectrum_index,\n          signals_codes,\n          results_to_save,\n          imported_data$buck_step,\n          resulting_data$final_output)\n      } else {\n\t  resulting_data$program_parameters=program_parameters\n    resulting_data$results_to_save=results_to_save\n    resulting_data$ROI_profile=ROI_profile\n    resulting_data$Ydata=Ydata\n    resulting_data$plot_data=plot_data[,ROI_buckets]\n    resulting_data$FeaturesMatrix=FeaturesMatrix\n    resulting_data$error1=error1\n    resulting_data$signals_parameters=signals_parameters\n    resulting_data$Xdata=Xdata\n\t}\n\n    }\n\n\t    if (identical(ind,seq(nrow(imported_data$dataset))))  setTxtProgressBar(pb, spectrum_index)\n    # if (fitting_type == \"Clean Sum\" || fitting_type == \"Baseline Sum\"&&identical(ind,seq(nrow(imported_data$dataset)))) {\n    #\n    #   dummy=integration_error(ROI_data,useful_data,final_output,signals_codes)\n    #   resulting_data$useful_data=dummy$useful_data\n    #   resulting_data$final_output=dummy$final_output\n\n    }\n\tif (interface == T) {\n\t\tresulting_data$p=p\n\t\tresulting_data$results_to_save=results_to_save\n\t\tresulting_data$spectrum_index=spectrum_index\n\t\tresulting_data$signals_codes=signals_codes\n\t\tresulting_data$fitting_type=fitting_type\n\t\t# resulting_data$signals_names=signals_names\n\t}\n  # }\n  return(resulting_data)\n}\n",
    "created" : 1493447931380.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2170441472",
    "id" : "C872146F",
    "lastKnownWriteTime" : 1493452619,
    "last_content_update" : 1493452619071,
    "path" : "~/GitHub/rDolphin/R/not_automatic_quant.R",
    "project_path" : "R/not_automatic_quant.R",
    "properties" : {
    },
    "relative_order" : 8,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}