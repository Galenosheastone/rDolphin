{
    "collab_server" : "",
    "contents" : "#Workflow of optimization of metabolite and baseline signals parameters. There are several optimization iterations (\"iter\") and the one with less error is chosen. The maximum number of iterations depends on the complexity of the ROI. Then the half bandwidth and j coupling are optimized separately as they have diferent behavior with the least squares algorithm. After the first fitting there can be further ones, depending on the need to add additional signals to adapt the signals and ROI information provided by the user to the concrete characteristics of the spectrum.\n\n\nfittingloop = function(FeaturesMatrix,Xdata,Ydata,program_parameters) {\n\n#Preallocation of output and setting of necessary variables for loop\n  signals_parameters=rep(0,length(as.vector(t(FeaturesMatrix[, seq(1, 9, 2), drop = F]))))\n  iterrep = 0\n  fitting_maxiterrep = program_parameters$fitting_maxiterrep\n  signals_to_quantify = which(FeaturesMatrix[, 11] != 0)\n  paramprov=rep(0,nrow(FeaturesMatrix)*5)\n\n\n  #Necessary information to incorporate additional signals if necessary\n  range_ind = round(program_parameters$additional_signal_ppm_distance / program_parameters$buck_step)\n\n\n  #Function where to find a minimum\n  residFun <-\n    function(par, observed, xx,multiplicities,roof_effect,freq)\n      observed - colSums(signal_fitting(par, xx,multiplicities,roof_effect,freq))\n\n\n  # Loop to control if additional signals are incorporated, until a maximum of iterations specified bt fitting_maxiterrep.\n  # If at the last fitting the improvement was lesser than 25% respective to the previous fitting,\n  # iterrep becomes equal to fitting_maxiterrep and the loop is stooped\n  while (iterrep <= fitting_maxiterrep) {\n\n    iter = 0\n    errorprov = error1 = 3000\n    worsterror = 0\n    dummy = error2 = 3000\n    multiplicities=FeaturesMatrix[,11]\n    roof_effect=FeaturesMatrix[,12]\n\n    #Depending on the complexity of the ROI, more or less iterations are performed\n    if (is.numeric(program_parameters$fitting_maxiter)) {\n      fitting_maxiter = program_parameters$fitting_maxiter\n    } else {\n      if (nrow(FeaturesMatrix)> 8 |\n          any(FeaturesMatrix[, 4] - FeaturesMatrix[, 3] > 0.01)) {\n        fitting_maxiter = 20\n      } else if ((nrow(FeaturesMatrix)> 5 &&\n          nrow(FeaturesMatrix)< 9)) {\n        fitting_maxiter = 14\n      } else {\n        fitting_maxiter = 8\n      }\n    }\n\n\n    #Conditions to keep the loop:\n    # -The error is bigger than the specified in program_parameters\n    # -There is no fitting with more than 66.7% improvement from the worst solution\n    # -The loop has not arrived the specified maximum of iterations\n     while (error1 > program_parameters$errorprov &error1 > (1 / 3 * worsterror) & iter < fitting_maxiter) {\n      #Initialization of parameters to optimize. In every iteration the initialization will be different\n      lb = as.vector(t(FeaturesMatrix[, seq(1, 9, 2), drop = F]))\n      ub = as.vector(t(FeaturesMatrix[, seq(2, 10, 2), drop = F]))\n      s0 = lb + (ub - lb) * runif(length(ub))\n      order1=order(rowMeans(FeaturesMatrix[signals_to_quantify ,3:4,drop=F])[signals_to_quantify])\n\n      # aaa=iter%%3/3\n      # bbb=ifelse((iter+1)%%3/3==0,1,(iter+1)%%3/3)\n      # s0[which(seq_along(s0)%%5==2)]=lb[which(seq_along(s0)%%5==2)] + (ub[which(seq_along(s0)%%5==2)] - lb[which(seq_along(s0)%%5==2)]) * runif(1,min=aaa,max=bbb)\n\n      #During the first two iterations, find the peaks on the region of the spectrum. If the number of peaks is the same that the expected on the ROI and the location is similar, the signals are located where there are the peaks with minimum shift tolerance.\n      peaks_xdata = peakdet(c(Ydata[1],diff(Ydata)), program_parameters$peakdet_minimum*0.1*max(1e-10,max(Ydata)),Xdata)\n\n      if (iter<4&length(peaks_xdata$maxtab$val)>0) {\n        peaks_bindata = peakdet(c(Ydata[1],diff(Ydata)), program_parameters$peakdet_minimum*0.1*max(1e-10,max(Ydata)))\n        peaks=peaks_xdata$maxtab$pos[sort(peaks_xdata$maxtab$val,decreasing=T,index.return=T)$ix[1:sum(multiplicities[signals_to_quantify])]]\n        peaks_compare=rowMeans(FeaturesMatrix[signals_to_quantify ,3:4,drop=F])\n      for (i in 1:length(peaks_compare)) {\n            ind=sort(abs(peaks-peaks_compare[i]),index.return=T)$ix[1:multiplicities[i]]\n            if (!is.na(mean(peaks[ind]))&&mean(peaks[ind])>FeaturesMatrix[i,3]&&mean(peaks[ind])<FeaturesMatrix[i,4]) {\n              s0[which(seq_along(s0)%%5==2)[i]]=mean(peaks[ind])\n              lb[which(seq_along(s0)%%5==2)[i]]=mean(peaks[ind])-0.001\n              ub[which(seq_along(s0)%%5==2)[i]]=mean(peaks[ind])+0.001\n          }\n      }\n\n      #Main optimization\n      nls.out <-\n        nls.lm(\n          par = s0,\n          fn = residFun,\n          observed = Ydata,\n          xx = Xdata,\n          multiplicities=multiplicities,\n          roof_effect=roof_effect,\n          freq=program_parameters$freq,\n          lower = lb,\n          upper = ub,\n          control = nls.lm.control(\n            factor = program_parameters$factor,\n            maxiter = program_parameters$nls_lm_maxiter,\n            ftol = program_parameters$ftol,\n            ptol = program_parameters$ptol\n          )\n        )\n\n      # #Procedure to calculate the fititng error in all the ROI\n      #An adapted MSE error is calculated, and the parameters of the optimization with less MSE are stored\n        iter = iter + 1\n        order2=order(coef(nls.out)[which(seq_along(coef(nls.out))%%5==2)][signals_to_quantify])\n\n        errorprov = (sqrt(nls.out$deviance / length(Ydata))) * 100 / (max(Ydata) -min(Ydata))\n        if (is.nan(errorprov) || is.na(errorprov)) errorprov = error1\n        if (errorprov < error1 && identical(order1,order2)) {\n          error1 = errorprov\n          paramprov=coef(nls.out)\n        } else if (errorprov > worsterror) {\n          worsterror = errorprov\n        }\n      } else {\n#If in the first two iterations the procedure of finding peaks is not effective enough, the irignal chemical shift and chemical shift tolerance of every signal is maintained\n      nls.out <-\n        nls.lm(\n          par = s0,\n          fn = residFun,\n          observed = Ydata,\n          xx = Xdata,\n          multiplicities=multiplicities,\n          roof_effect=roof_effect,\n        freq=program_parameters$freq,\n          lower = lb,\n          upper = ub,\n          control = nls.lm.control(\n            factor = program_parameters$factor,\n            maxiter = program_parameters$nls_lm_maxiter,\n            ftol = program_parameters$ftol,\n            ptol = program_parameters$ptol\n          )\n\n        )\n\n      iter = iter + 1\n\n      order2=order(coef(nls.out)[which(seq_along(coef(nls.out))%%5==2)][signals_to_quantify])\n      # #Procedure to calculate the fititng error in all the ROI\n      #An adapted MSE error is calculated, and the parameters of the optimization with less MSE are stored\n      errorprov = (sqrt(nls.out$deviance / length(Ydata))) * 100 / (max(Ydata) -min(Ydata))\n      if (is.nan(errorprov) || is.na(errorprov))errorprov = error1\n      if (errorprov < error1 && identical(order1,order2)) {\n        error1 = errorprov\n        paramprov=coef(nls.out)\n      } else if (errorprov > worsterror) {\n        worsterror = errorprov\n      }\n    }}\n    signals_parameters = paramprov\n\n    #Correction of half_band_width and j-coupling\n    iter = 0\n    error2=error1\n    errorprov = error1=3000\n    #Only half_band_width and j-coupling will have different lower und upper bounds.\n    change_indexes=which(seq_along(lb)%%5!=3 & seq_along(lb)%%5!=4 & seq_along(lb)%%5!=0)\n    lb[change_indexes]=ub[change_indexes]=paramprov[change_indexes]\n    #With ony one iteration is enough\n    while (iter < 3) {\n      s0 = lb + (ub - lb) * runif(length(ub))\n\n      nls.out <-\n        nls.lm(\n          par = s0,\n          fn = residFun,\n          observed = Ydata,\n          xx = Xdata,\n          multiplicities=multiplicities,\n          roof_effect=roof_effect,\n          freq=program_parameters$freq,\n          lower = lb,\n          upper = ub,\n          control = nls.lm.control(\n            factor = program_parameters$factor,\n            maxiter = program_parameters$nls_lm_maxiter,\n            ftol = program_parameters$ftol,\n            ptol = program_parameters$ptol\n          )\n\n        )\n      iter = iter + 1\n      # #Procedure to calculate the fititng error in all the ROI\n      #An adapted MSE error is calculated, and the parameters of the optimization with less MSE are stored\n      errorprov = (sqrt(nls.out$deviance / length(Ydata))) * 100 / (max(Ydata) -\n          min(Ydata))\n      if (is.nan(errorprov) || is.na(errorprov)) errorprov = error1\n      if (errorprov < error1) {\n        error1 = errorprov\n        paramprov=coef(nls.out)\n      } else if (errorprov > worsterror) {\n        worsterror = errorprov\n      }\n      if (error1 < error2) {\n        error2 = error1\n        signals_parameters = paramprov\n      }\n    }\n\n    #If half_band_width and j-coup change improves fitting\n\n\n    iterrep = iterrep + 1\n\n    #If the fitting seems to be still clearly improvable through the addition of signals\n    if (iterrep <= fitting_maxiterrep& error2 < (program_parameters$additional_signal_improvement * dummy) &\n        (error2 > program_parameters$additional_signal_percentage_limit)&length(peaks_xdata$maxtab$pos)>sum(multiplicities[signals_to_quantify])) {\n      # print('Trying to improve initial fit adding peaks')\n\n      #I find peaks on the residuals\n      residual_peaks = tryCatch(peakdet(c(nls.out$fvec[1],diff(nls.out$fvec)), program_parameters$peakdet_minimum*max(1e-10,max(Ydata))),error= function(e){\n        dummy=list(signals_parameters=signals_parameters,error1=error1)\n        return(dummy)\n      })\n\n      if (is.null(residual_peaks$maxtab) == F) {\n        #Preparation of information of where signals of interest are located\n        dummy=multiplicities[signals_to_quantify]%%2\n        dummy[dummy==0]=2\n        additional_signal_matrix = matrix(paramprov,nrow(FeaturesMatrix),5,byrow = TRUE)\n        points_to_avoid = abs(rbind(matrix(Xdata,length(signals_to_quantify),length(Xdata),byrow = TRUE) - matrix(\n            additional_signal_matrix[signals_to_quantify, 2] - (additional_signal_matrix[signals_to_quantify, 5]/dummy)/program_parameters$freq,length(signals_to_quantify),length(Xdata)),\n          matrix(Xdata,length(signals_to_quantify),length(Xdata),byrow = TRUE) - matrix(additional_signal_matrix[signals_to_quantify, 2] + (additional_signal_matrix[signals_to_quantify, 5]/dummy)/program_parameters$freq,length(signals_to_quantify),length(Xdata))))\n        points_to_avoid = apply(points_to_avoid, 1, which.min)\n        seq_range = c()\n        for (i in (-range_ind):range_ind) seq_range = append(seq_range, points_to_avoid - i)\n\n        #Finding of posible additional signals to incorporate if there are not in zones where the signals o interest are located\n        residual_peaks=cbind(residual_peaks$maxtab$pos, residual_peaks$maxtab$val)[residual_peaks$maxtab$pos %in% peaks_bindata$maxtab$pos,,drop=F]\n        valid_residual_peaks = matrix(NA, 0, 2)\n        if (nrow(residual_peaks)>0) {\n        for (i in seq(nrow(residual_peaks))) {\n          if (any(abs(points_to_avoid - residual_peaks[i, 1]) < range_ind) == F) valid_residual_peaks = rbind(valid_residual_peaks, residual_peaks[i, ])\n        }\n          #Selection of more intense additional signals\n        if (nrow(valid_residual_peaks) > program_parameters$signals_to_add) {\n          ad = sort(valid_residual_peaks[, 2],decreasing = T,index.return = T)$ix\n          valid_residual_peaks = valid_residual_peaks[ad[1:min(program_parameters$signals_to_add, length(ad))], , drop = F]\n        }\n        #Creation of rows to incorporate to FeaturesMatrix\n         if (nrow(valid_residual_peaks)>0) {\n           dummy = t(replicate(nrow(valid_residual_peaks),FeaturesMatrix[1,]))\n          dummy[, 1] = Ydata[valid_residual_peaks[, 1]]\n        dummy[, 3] = Xdata[valid_residual_peaks[, 1]] - 0.001\n        dummy[, 4] = Xdata[valid_residual_peaks[, 1]] + 0.001\n        dummy[, 5]=min(FeaturesMatrix[,5])\n        dummy[, 6]=min(FeaturesMatrix[,6])\n        dummy[, c(9,10,12)] = rep(0, nrow(valid_residual_peaks))\n        dummy[, 11] = rep(1, nrow(valid_residual_peaks))\n        FeaturesMatrix = rbind(FeaturesMatrix, dummy)\n         } else {\n           iterrep = fitting_maxiterrep +1\n           }\n        } else  {\n          iterrep = fitting_maxiterrep +1\n      }}\n    } else {\n      iterrep = fitting_maxiterrep +1\n    }\n\n  }\n  optim_parameters=list(signals_parameters=signals_parameters,error1=error1)\n  return(optim_parameters)\n}\n",
    "created" : 1494245290054.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3162866940",
    "id" : "5EFDC3A4",
    "lastKnownWriteTime" : 1494250262,
    "last_content_update" : 1494250262627,
    "path" : "~/GitHub/rDolphin/R/fittingloop.R",
    "project_path" : "R/fittingloop.R",
    "properties" : {
    },
    "relative_order" : 12,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}