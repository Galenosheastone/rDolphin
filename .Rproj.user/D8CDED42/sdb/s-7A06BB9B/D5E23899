{
    "collab_server" : "",
    "contents" : "#' Creation of matrix to validate quantifications, with information of difference with predicted shift, signal to total area ratio, fitting error, and difference with expected relative intensity\n#'\n#' @param final_output List with quantifications and indicators of quality of quantification.\n#' @param validation_type Type of valdiation to perform (1: fitting error, 2: signal area ratio, 3: chemical shift, 4: half bandwidth, 5: outliers, 6: relative intensity of signals of same metabolite)\n#' @param ROI_data ROIs data\n#' @param metadata Dataset metadata\n#'\n#' @return Matrix with data required\n#' @export validation\n#' @import robust\n#' @import robustbase\n#'\n#' @examples\n#' setwd(paste(system.file(package = \"rDolphin\"),\"extdata\",sep='/'))\n#' load(\"MTBLS242_subset_example.RData\")\n#' validation_data=validation(quantification_variables$final_output,5,imported_data$ROI_data,imported_data$Metadata)\n\n\n\nvalidation = function(final_output,validation_type,ROI_data,metadata) {\n\nif (is.null(final_output)) return(NULL)\n    alarmmatrix=matrix(NA,dim(final_output$shift)[1],dim(final_output$shift)[2],dimnames=list(rownames(final_output$shift),colnames(final_output$shift)))\n\n   #Analysis of fitting error of quantifications\n\n  if (validation_type==1) {\n  alarmmatrix=final_output$fitting_error\n  brks <- seq(0.01,0.19,0.01)\n  clrs <- round(seq(255, 40, length.out = length(brks) + 1), 0) %>%\n  {paste0(\"rgb(255,\", ., \",\", ., \")\")}\n\n\t#Analysis of which quantifications have too low signal to toal area ratio\n\n} else if (validation_type==2) {\n  alarmmatrix=final_output$signal_area_ratio\n  brks <- seq(0,20,length.out=19)\n  clrs <- round(seq(40, 255, length.out = length(brks) + 1), 0) %>%\n  {paste0(\"rgb(255,\", ., \",\", ., \")\")}\n\n\t#Analysis of which quantifications deviate too much from expected shift, according to prediction with linear model of signals with similar behavior\n\n} else if (validation_type==3) {\n\n  # ind=which(apply(final_output$shift,2, function(x) all(is.na(x)))==F) #find quantified signals\n  # shift_corrmatrix=cor(final_output$shift,use='pairwise.complete.obs',method='spearman')\n  #\n  # for (i in ind) {\n  #   similar_signals=final_output$shift[,unique(c(i,ind[sort(abs(shift_corrmatrix[,i]),decreasing=T,index.return=T)$ix][1:3]))]\n  #  j=is.na(rowMeans(similar_signals)) #find signals with similar behavior\n  #  #Create linear models with two most simila signals and predict shift\n  #    lm_similar_signals=tryCatch({lmrob(similar_signals[!j,1] ~ similar_signals[!j,2],control = lmrob.control(maxit.scale=5000))},error= function(e) {lm(similar_signals[!j,1] ~ similar_signals[!j,2])},warning= function(e) {lm(similar_signals[!j,1] ~ similar_signals[!j,2])})\n  #   prediction_similar_signal_1=suppressWarnings(predict(lm_similar_signals, interval='prediction'))\n  #   lm_similar_signals=tryCatch({lmrob(similar_signals[!j,1] ~ similar_signals[!j,3],control = lmrob.control(maxit.scale=5000))},error= function(e) {lm(similar_signals[!j,1] ~ similar_signals[!j,3])},warning= function(e) {lm(similar_signals[!j,1] ~ similar_signals[!j,3])})\n  #   prediction_similar_signal_2=suppressWarnings(predict(lm_similar_signals, interval='prediction'))\n  # alarmmatrix[!j,i]=apply(rbind(final_output$shift[!j,i]-prediction_similar_signal_1[,1],final_output$shift[!j,i]-prediction_similar_signal_2[,1]),2,min)\n  # }\n  shift=final_output$shift\n  # shift=shift[,-which(is.na(shift[1,]))]\n  # shift=data.matrix(shift[,-1])\n\n  for (i in seq(ncol(shift))) {\n    mm=rep(NA,ncol(shift))\n    for (j in 1:ncol(shift)) mm[j]=tryCatch(suppressWarnings(summary(lmrob(shift[,i]~shift[,j]))$sigma),error=function(e)NaN)\n    if (all(is.na(mm))) next\n    def=predict(lmrob(shift[,i]~shift[,order(mm)[1:20]],max.it = 1000))\n    alarmmatrix[,i]=shift[,i]-def\n  }\n  brks <-c(-seq(max(abs(alarmmatrix),na.rm=T), 0, length.out=10),seq(0, max(abs(alarmmatrix),na.rm=T), length.out=10)[-1])\n  clrs <- round(c(seq(40, 255, length.out = (length(brks) + 1)/2),seq(255, 40, length.out = (length(brks) + 1)/2)), 0) %>%\n  {paste0(\"rgb(255,\", ., \",\", ., \")\")}\n\n  \t#Analysis of which quantifications deviate too much from expected half_band_width, according to prediction with linear model of spectra with similar behavior\n\n  } else if (validation_type==4) {\n  #   ind=which(apply(final_output$half_band_width,2, function(x) all(is.na(x)))==F)#find signals with quantified half_band_width\n  # medianwidth=apply(final_output$half_band_width,2,function(x)median(x,na.rm=T))\n  # for (i in 1:dim(final_output$half_band_width)[1]) {\n  #    #Create linear model with most similar half_band_width and predict them\n  #   lm_similar_spectrum=tryCatch({lmrob(as.numeric(final_output$half_band_width[i,]) ~ medianwidth,control = lmrob.control(maxit.scale=5000))},error= function(e) {lm(as.numeric(final_output$half_band_width[i,]) ~ medianwidth)},warning= function(e) {lm(as.numeric(final_output$half_band_width[i,]) ~ medianwidth)})\n  #   prediction_similar_spectrum=suppressWarnings(predict(lm_similar_spectrum, interval='prediction'))\n  #   alarmmatrix[i,ind][!is.na(final_output$half_band_width[i,ind])]=final_output$half_band_width[i,ind][!is.na(final_output$half_band_width[i,ind])]-prediction_similar_spectrum[,1]\n  # }\n    half_band_width=final_output$half_band_width\n\n    ind=which(final_output$fitting_error>0.05)\n    half_band_width[ind]=NA\n    ab=t(replicate(nrow(half_band_width),apply(half_band_width,2,function(x)median(x,na.rm=T))))\n    ac=half_band_width/ab\n    ad=apply(ac,1,function(x)median(x,na.rm=T))\n    matr4=ab*replicate(ncol(half_band_width),ad)\n    alarmmatrix=half_band_width-matr4\n  brks <-c(-seq(max(abs(alarmmatrix),na.rm=T), 0, length.out=10),seq(0, max(abs(alarmmatrix),na.rm=T), length.out=10)[-1])\n  clrs <- round(c(seq(40, 255, length.out = (length(brks) + 1)/2),seq(255, 40, length.out = (length(brks) + 1)/2)), 0) %>%\n  {paste0(\"rgb(255,\", ., \",\", ., \")\")}\n\n  #Analysis of outliers for every class and of their magnitude\n\n  } else if (validation_type==5) {\n\n metadata_types=unique(metadata[,2])\n    for (k in 1:length(metadata_types)) {\n    iqr_data=apply(final_output$quantification[metadata[,2]==metadata_types[k],],2,function(x) IQR(x,na.rm=T))\n    quartile_data=rbind(apply(final_output$quantification[metadata[,2]==metadata_types[k],],2,function(x) quantile(x,0.25,na.rm=T)),apply(final_output$quantification[metadata[,2]==metadata_types[k],],2,function(x) quantile(x,0.75,na.rm=T)))\n    for (i in which(metadata[,2]==metadata_types[k])) {\n      for (j in which(!is.na(iqr_data))) {\n        if (!is.na(final_output$quantification[i,j]) && final_output$quantification[i,j]>quartile_data[1,j]&&final_output$quantification[i,j]<quartile_data[2,j]) {\n          alarmmatrix[i,j]=0\n        } else if (!is.na(final_output$quantification[i,j]) &&final_output$quantification[i,j]<quartile_data[1,j]) {\n          alarmmatrix[i,j]=abs(final_output$quantification[i,j]-quartile_data[1,j])/iqr_data[j]\n        } else if (!is.na(final_output$quantification[i,j]) &&final_output$quantification[i,j]>quartile_data[2,j]) {\n          alarmmatrix[i,j]=abs(final_output$quantification[i,j]-quartile_data[2,j])/iqr_data[j]\n        }\n      }\n    }}\n  brks <- quantile(alarmmatrix, probs = seq(.05, .95, .05), na.rm = TRUE)\n  clrs <- round(seq(255, 40, length.out = length(brks) + 1), 0) %>%\n  {paste0(\"rgb(255,\", ., \",\", ., \")\")}\n\n    #Analysis of difference with expected intensity comparing with another signal from the same metabolite\n\n  } else if (validation_type==6) {\n\n  #   relative_intensity = ROI_data[,12]\n  #\n  #   alarmmatrix=final_output$intensity\n  #   alarmmatrix[,]=NA\n  #   ind=unique(ROI_data[,4][duplicated(ROI_data[,4])])\n  #   for (i in seq_along(ind)) {\n  #     ab=which(ROI_data[,4]==ind[i])\n  #     ab2=ab[which.min(colMeans(final_output$fitting_error[,ab],na.rm=T))]\n  #     if (length(ab2)>0) alarmmatrix[,ab]=(final_output$intensity[,ab]/final_output$intensity[,ab2])*relative_intensity[ab]\n  #\n  # }\n    shift=final_output$quantification\n    # shift=shift[,-which(is.na(shift[1,]))]\n    # shift=data.matrix(shift[,-1])\n\n    for (i in seq(ncol(shift))) {\n      mm=rep(NA,ncol(shift))\n      for (j in 1:ncol(shift)) mm[j]=tryCatch(suppressWarnings(summary(lmrob(shift[,i]~shift[,j]))$sigma),error=function(e)NaN)\n      if (all(is.na(mm))) next\n      def=predict(lmrob(shift[,i]~shift[,order(mm)[1:20]],max.it = 1000))\n      alarmmatrix[,i]=shift[,i]-def\n    }\n    brks <-c(-seq(max(abs(alarmmatrix),na.rm=T), 0, length.out=10),seq(0, max(abs(alarmmatrix),na.rm=T), length.out=10)[-1])\n    clrs <- round(c(seq(40, 255, length.out = (length(brks) + 1)/2),seq(255, 40, length.out = (length(brks) + 1)/2)), 0) %>%\n    {paste0(\"rgb(255,\", ., \",\", ., \")\")}\n\n    # brks <- c(seq(0.25, 1,length.out = 10), seq(1, 4, length.out = 10)[-1])\n    # clrs <- round(c(seq(40, 255, length.out = (length(brks) + 1)/2),seq(255, 40, length.out = (length(brks) + 1)/2)), 0) %>%\n    # {paste0(\"rgb(255,\", ., \",\", ., \")\")}\n  }\n\n\n\nvalidationdata=list(alarmmatrix=alarmmatrix,brks=brks,clrs=clrs)\n\nreturn(validationdata)\n}\n",
    "created" : 1494504891805.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3282017813",
    "id" : "D5E23899",
    "lastKnownWriteTime" : 1494506678,
    "last_content_update" : 1494506678362,
    "path" : "~/GitHub/rDolphin/R/validation.R",
    "project_path" : "R/validation.R",
    "properties" : {
    },
    "relative_order" : 25,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}