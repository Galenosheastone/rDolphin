{
    "collab_server" : "",
    "contents" : "\n#' Automatic quantification of signals for all experiments using the information located in the ROI patterns file.\n#'\n#' @param imported_data List with typical elements necessary to perform quantification of ROIs.\n#' @param final_output List with quantifications and indicators of quality of quantification.\n#' @param useful_data List with necessary information to load quantifications on the Shiny GUI.\n#' @param ROI_data ROIs data.\n#'\n#' @return List with updated final_output and useful_data variables.\n#' @export autorun\n#' @import baseline\n#'\n#' @examples\n#' setwd(paste(system.file(package = \"rDolphin\"),\"extdata\",sep='/'))\n#' imported_data=import_data(\"Parameters_MTBLS242_15spectra_5groups.csv\")\n#' # Not run:\n#' # quantification_variables=autorun(imported_data,imported_data$final_output,imported_data$useful_data,imported_data$ROI_data)\n\n\nautorun_correction_4 = function(imported_data, final_output,useful_data,ROI_data) {\n  shift=final_output$shift\n  # shift=shift[,-which(is.na(shift[1,]))]\n  # shift=data.matrix(shift[,-1])\n  matr=matr3=matrix(NA,nrow(shift),ncol(shift))\n  # for (i in seq(ncol(shift))) {\n  #\n  #   mm=rep(NA,ncol(shift))\n  #   for (j in 1:ncol(shift)) mm[j]=tryCatch(summary(lmrob(shift[,i]~shift[,j]))$sigma,error=function(e)NaN)\n  #\n  #   # sen=sapply(2:20,function(x)summary(lmrob(shift[,i]~apply(shift[,order(mm)[1:x]],1,mean)))$sigma)\n  #   sen2=rep(NA,ncol(shift))\n  #   sen2[1]=tryCatch(summary(lmrob(shift[,i]~shift[,which.min(mm)]))$sigma,error=function(e)NaN)\n  #   for (j in 2:ncol(shift)) sen2[j]=tryCatch(summary(lmrob(shift[,i]~apply(shift[,order(mm)[1:j]],1,mean)))$sigma,error=function(e)NaN)\n  #   # sen2=sapply(2:20,function(x)summary(lmrob(shift[,i]~apply(shift[,order(mm)[1:x]],1,median)))$sigma)\n  #   if (all(is.na(sen2))) next\n  #   if (which.min(sen2)==1) {\n  #     def=predict(lmrob(shift[,i]~shift[,which.min(mm)]))\n  #   } else {\n  #   def=predict(lmrob(shift[,i]~apply(shift[,order(mm)[1:which.min(sen2)]],1,mean)))\n  #   }\n  #   matr[,i]=shift[,i]-def\n  #   matr3[,i]=def\n  # }\n\n  for (i in seq(ncol(shift))) {\n    mm=rep(NA,ncol(shift))\n    for (j in 1:ncol(shift)) mm[j]=tryCatch(summary(lmrob(shift[,i]~shift[,j]))$sigma,error=function(e)NaN)\n    if (all(is.na(mm))) next\n    def=predict(lmrob(shift[,i]~shift[,order(mm)[2:20]],max.it = 1000))\n    matr[,i]=shift[,i]-def\n    matr3[,i]=def\n  }\n\n  ll=apply(abs(matr),2,function(x)quantile(x,0.9,na.rm=T))\n  ind=is.na(ll)\n\n  ll[ind]=ROI_data[ind,7]\n  matr3[,ind]=t(replicate(nrow(shift),ROI_data[ind,6]))\n\n\n  half_band_width=final_output$half_band_width\n\n  # matr2=matr4=matrix(NA,nrow(half_band_width),ncol(half_band_width))\n  # for (i in seq(nrow(half_band_width))) {\n  #\n  #   mm=rep(NA,nrow(half_band_width))\n  #   for (j in 1:nrow(half_band_width)) mm[j]=tryCatch(summary(lmrob(half_band_width[i,]~half_band_width[j,]))$sigma,error=function(e)NaN)\n  #\n  #   # sen=sapply(2:20,function(x)summary(lmrob(half_band_width[,i]~apply(half_band_width[,order(mm)[1:x]],1,mean)))$sigma)\n  #   sen2=rep(NA,nrow(half_band_width))\n  #   for (j in 2:nrow(half_band_width)) sen2[j]=tryCatch(summary(lmrob(half_band_width[i,]~apply(half_band_width[order(mm)[1:j],],2,median)))$sigma,error=function(e)NaN)\n  #   # sen2=sapply(2:20,function(x)summary(lmrob(half_band_width[,i]~apply(half_band_width[,order(mm)[1:x]],1,median)))$sigma)\n  #   if (all(is.na(sen2))) next\n  #\n  #   def=predict(lmrob(half_band_width[i,]~apply(half_band_width[order(mm)[1:which.min(sen2)],],2,median)),as.data.frame(half_band_width[i,]))\n  #\n  #   matr2[i,]=half_band_width[i,]-def\n  #   matr4[i,]=def\n  # }\n  ind=which(final_output$fitting_error>0.05)\n  half_band_width[ind]=NA\n  ab=t(replicate(nrow(half_band_width),apply(half_band_width,2,function(x)median(x,na.rm=T))))\n  ac=half_band_width/ab\n  ad=apply(ac,1,function(x)median(x,na.rm=T))\n  matr4=ab*replicate(ncol(half_band_width),ad)\n  # matr2=matr/apply(abs(matr),2,median)\n  # ll=apply(abs(matr2),2,function(x)quantile(x,0.9,na.rm=T))\n\n\n  matr4[,is.na(half_band_width[1,])]=t(replicate(nrow(half_band_width),ROI_data[is.na(half_band_width[1,]),8]))\n\n\n  print('Be patient. Gonna take a while. You should be writing, meanwhile.')\n\n  #Splitting of ROI data into individual ROIs to be quantified\n\tdummy = which(is.na(ROI_data[, 1]))\n    if (length(dummy)==0) dummy=dim(ROI_data)[1]+1\n    lal=which(duplicated(ROI_data[-dummy,1:2])==F)\n    ROI_separator = cbind(lal, c(lal[-1] - 1, dim(ROI_data[-dummy,])[1]))\n\n  baselinedataset=baseline::baseline.rollingBall(imported_data$dataset,5,5)$baseline\n\n  #For every ROI\n  for (ROI_index in seq_along(ROI_separator[, 1])) {\n\n    #Preparation of ROI parameters\n    ROI_profile = ROI_data[ROI_separator[ROI_index, 1]:ROI_separator[ROI_index, 2],]\n    ROI_buckets = which.min(abs(as.numeric(ROI_profile[1, 1])-imported_data$ppm)):which.min(abs(as.numeric(ROI_profile[1, 2])-imported_data$ppm))\n    if (length(ROI_buckets)<5) next\n    if (ROI_buckets[1]>ROI_buckets[2]) ROI_buckets=rev(ROI_buckets)\n\n\n    #Preparation of program parameters to be sued during fitting, with some variables added to ease interpretability of code\n    program_parameters=imported_data$program_parameters\n    program_parameters$freq = imported_data$freq\n    program_parameters$ROI_buckets = ROI_buckets\n    program_parameters$buck_step = imported_data$buck_step\n\n    Xdata = imported_data$ppm[ROI_buckets]\n    fitting_type = as.character(ROI_profile[1, 3])\n    if (length(grep(\"Clean\",fitting_type))==1) {\n      program_parameters$clean_fit=\"Y\"\n    } else {\n      program_parameters$clean_fit=\"N\"\n    }\n\tsignals_to_quantify = which(ROI_profile[, 5] >= 1)\n\tsignals_codes = (ROI_separator[ROI_index, 1]:ROI_separator[ROI_index, 2])[signals_to_quantify]\n\n\n    print(paste(ROI_profile[1,1], ROI_profile[1,2], sep = '-'))\n    print(paste('ROI',ROI_index,'of',nrow(ROI_separator)))\n\n\n    index_to_use=unique(unlist(apply(matr[,ROI_separator[ROI_index, 1]:ROI_separator[ROI_index, 2],drop=F],2,function(x)which(x %in% boxplot.stats(x)$out==T))))\n\n    #Quantification for every spectrum\n    pb   <- txtProgressBar(1, nrow(imported_data$dataset), style=3)\n    for (spectrum_index in index_to_use) {\n\n\n      #Preparation of necessary variables to store figures and information of the fitting\n      Ydata = as.numeric(imported_data$dataset[spectrum_index, ROI_buckets])\n\n      #If the quantification is through integration with or without baseline\n      if (fitting_type == \"Clean Sum\" ||\n          fitting_type == \"Baseline Sum\") {\n        #Fitting error is calculated through the comparison with the median spectrum, so singals interfering with the integration can be controlled\n        # program_parameters$clean_fit = ifelse(fitting_type == \"Clean Sum\", \"Y\",\n        #                                       \"N\")\n        # program_parameters$freq=imported_data$freq\n        # baseline_int = fitting_prep_integration(Xdata,Ydata,program_parameters,baselinedataset[spectrum_index, ROI_buckets])\n        # Ydatamedian=as.numeric(apply(imported_data$dataset[, ROI_buckets,drop=F],2,median))\n        dummy = integration(program_parameters$clean_fit, Xdata,Ydata)\n\n        results_to_save=dummy$results_to_save\n        #Generation of useful variables specific of every quantification\n        useful_data[[spectrum_index]][[signals_codes]]$ROI_profile=ROI_profile\n        useful_data[[spectrum_index]][[signals_codes]]$plot_data=dummy$plot_data\n        useful_data[[spectrum_index]][[signals_codes]]$Xdata=Xdata\n        useful_data[[spectrum_index]][[signals_codes]]$Ydata=Ydata\n        useful_data[[spectrum_index]][[signals_codes]]$results_to_save=results_to_save\n        useful_data[[spectrum_index]][[signals_codes]]$error1=results_to_save$fitting_error\n\n        #If the quantification is through fitting with or without baseline\n      } else if (fitting_type == \"Clean Fitting\" || fitting_type ==\n          \"Baseline Fitting\") {\n        program_parameters$widthtolerance = 0.15\n\n        ROI_profile[,6]=matr3[spectrum_index,ROI_separator[ROI_index, 1]:ROI_separator[ROI_index, 2]]\n        ROI_profile[,7]=ll[ROI_separator[ROI_index, 1]:ROI_separator[ROI_index, 2]]\n        ROI_profile[,8]=matr4[spectrum_index,ROI_separator[ROI_index, 1]:ROI_separator[ROI_index, 2]]\n        #Adaptation of the info of the parameters into a single matrix and preparation (if necessary) of the background signals that will conform the baseline\n        FeaturesMatrix = fitting_prep(Xdata,\n          Ydata,\n          ROI_profile[, 5:11,drop=F],\n          program_parameters,baselinedataset[spectrum_index,ROI_buckets])\n\n        #Calculation of the parameters that will achieve the best fitting\n        dummy = fittingloop(FeaturesMatrix,\n          Xdata,\n          Ydata,\n          program_parameters)\n        signals_parameters=dummy$signals_parameters\n\t\tXdata_2=imported_data$ppm\n\t    program_parameters$signals_to_quantify=signals_to_quantify\n\t\tYdata_2 = as.numeric(imported_data$dataset[spectrum_index, ])\n        #Fitting of the signals\n        multiplicities=c(FeaturesMatrix[,11],rep(1,(length(signals_parameters)/5)-dim(FeaturesMatrix)[1]))\n        roof_effect=c(FeaturesMatrix[,12],rep(0,(length(signals_parameters)/5)-dim(FeaturesMatrix)[1]))\n        fitted_signals = signal_fitting(signals_parameters,\n          Xdata_2,multiplicities,roof_effect,program_parameters$freq)\n               dim(signals_parameters) = c(5, length(signals_parameters)/5)\n        rownames(signals_parameters) = c('intensity','shift','half_band_width','gaussian','J_coupling')\n        signals_parameters=rbind(signals_parameters,multiplicities,roof_effect)\n\n        #Generation of output data about the fitting and of the necessary variables for the generation ofa figure\n        dummy = output_generator(signals_to_quantify,fitted_signals,Ydata_2,Xdata_2,signals_parameters,multiplicities)\n        output_data=dummy$output_data\n        error1=ifelse(is.nan(dummy$error1),3000,dummy$error1)\n\n        #If any of the qunatificaitons has more than 5% fitting error, try again the deconvolution\n        if (any(output_data$fitting_error>0.05)==T) {\n        dummy = fittingloop(FeaturesMatrix,Xdata,Ydata,program_parameters)\n        signals_parameters=dummy$signals_parameters\n\n\t\t#Fitting of the signals\n        multiplicities=c(FeaturesMatrix[,11],rep(1,(length(signals_parameters)/5)-dim(FeaturesMatrix)[1]))\n        roof_effect=c(FeaturesMatrix[,12],rep(0,(length(signals_parameters)/5)-dim(FeaturesMatrix)[1]))\n        fitted_signals = signal_fitting(signals_parameters,\n          Xdata_2,multiplicities,roof_effect,program_parameters$freq)\n        dim(signals_parameters) = c(5, length(signals_parameters)/5)\n\t\tsignals_parameters=rbind(signals_parameters,multiplicities,roof_effect)\n        rownames(signals_parameters) = c('intensity','shift','half_band_width','gaussian','J_coupling','multiplicities','roof effect')\n        if (fitting_type == \"Clean Fitting\") {\n          colnames(signals_parameters)=paste(ROI_profile[,4],ROI_profile[,5],sep='_')\n        } else {\n          colnames(signals_parameters)=c(paste(ROI_profile[,4],ROI_profile[,5],sep='_'),paste('baseline_signal',seq(ncol(signals_parameters)-nrow(ROI_profile)),sep='_'))\n        }\n        #Generation of output data about the fitting and of the necessary variables for the generation ofa figure\n        dummy = output_generator(signals_to_quantify,fitted_signals,Ydata_2,Xdata_2,signals_parameters,multiplicities)\n\n        #If new deconvolution has improved previous one\n        if (dummy$error1<error1) {\n          output_data=dummy$output_data\n          error1=dummy$error1\n        }}\n\n        #Generation of the dataframe with the final output variables\n        results_to_save = data.frame(\n          shift = output_data$shift,\n          quantification = output_data$quantification,\n          signal_area_ratio = output_data$signal_area_ratio,\n          fitting_error = output_data$fitting_error,\n          intensity = output_data$intensity,\n          half_band_width = output_data$half_band_width\n        )\n\n        #Generation of the figure data\n        plot_data = rbind(output_data$signals_sum,output_data$baseline_sum,output_data$fitted_sum,output_data$signals)\n        plot_data = plot_data[,ROI_buckets]\n\n         rownames(plot_data) = c(\"signals_sum\",\"baseline_sum\",\"fitted_sum\",as.character(paste(ROI_profile[,4],ROI_profile[,5],sep='_')),rep('additional signal',dim(plot_data)[1]-length(ROI_profile[,4])-3))\n\n        #Generation of useful variables specific of every quantification\n        for (i in seq_along(signals_codes)) {\n          useful_data[[spectrum_index]][[signals_codes[i]]]$ROI_profile=ROI_profile\n          useful_data[[spectrum_index]][[signals_codes[i]]]$program_parameters=program_parameters\n          useful_data[[spectrum_index]][[signals_codes[i]]]$plot_data=plot_data\n          useful_data[[spectrum_index]][[signals_codes[i]]]$error1=error1\n          useful_data[[spectrum_index]][[signals_codes[i]]]$FeaturesMatrix=FeaturesMatrix\n          useful_data[[spectrum_index]][[signals_codes[i]]]$signals_parameters=signals_parameters\n          useful_data[[spectrum_index]][[signals_codes[i]]]$Xdata=Xdata\n          useful_data[[spectrum_index]][[signals_codes[i]]]$Ydata=Ydata\n          useful_data[[spectrum_index]][[signals_codes[i]]]$results_to_save=results_to_save\n          }\n     }\n\n      #Generation of output variables specific of every quantification\n      final_output = save_output(spectrum_index,signals_codes,results_to_save,imported_data$buck_step,final_output)\n\n      setTxtProgressBar(pb, spectrum_index)\n      }\n\n  }\n  print(\"Done!\")\n#   ind=which(ROI_data[,3]==\"Clean Sum\"| ROI_data[,3]==\"Baseline Sum\")\n#   if (length(ind>0)) {\n#   dummy=integration_error(ROI_data,useful_data,final_output,ind)\n#   final_output=dummy$final_output\n#   useful_data=dummy$useful_data\n# }\n  quantification_variables=list(final_output=final_output,useful_data=useful_data)\n  return(quantification_variables)\n}\n",
    "created" : 1494413420977.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2416862943",
    "id" : "1FC09BC2",
    "lastKnownWriteTime" : 1494435324,
    "last_content_update" : 1494435324357,
    "path" : "~/autorun_correction_4.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 25,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}