{
    "collab_server" : "",
    "contents" : "\nfitting_prep = function(Xdata,Ydata,initial_fit_parameters,program_parameters,created_baseline) {\n  #Created by Daniel Canueto 30/08/2016\n  #Preparation of parameters to optimize to achieve the best fitting\n\n  colnames(initial_fit_parameters) = c(\n\t\"quantification_or_not\",\n    \"positions\",\n    \"shift_tolerance\",\n    \"widths\",\n    \"multiplicities\",\n    \"Jcoupling\",\n    \"roof_effect\"\n  )\n  Ydata[Ydata<0]=0\n  signals_to_fit = length(initial_fit_parameters$positions)\n  ROIlength = length(Xdata)\n\n\n  #Calculation of number of background signals, if baseline fitting is performed\n  BGSigNum = ifelse(program_parameters$clean_fit == 'N', max(round(abs(Xdata[1] -\n                                                                        Xdata[ROIlength]) * program_parameters$BGdensity), 3), 0)\n\n  #Preallocation of parameters to optimize into a matrix of features\n  FeaturesMatrix = matrix(NA, (signals_to_fit + BGSigNum), 12)\n  colnames(FeaturesMatrix) = c(\n    'minimum_intensity',\n    'maximum_intensity',\n    'shift_left_limit',\n    'shift_right_limit',\n    'minimum_width',\n    'maximum_width',\n    'minimum_gaussian',\n    'maximum_gaussian',\n    'minimum_J_coupling',\n    'maximum_J_coupling',\n    'multiplicities',\n    'roof_effect'\n  )\n\n  #Parameters of signals to fit\n  FeaturesMatrix[1:signals_to_fit, 1] = 0\n  FeaturesMatrix[1:signals_to_fit, 2] = max(Ydata)\n  FeaturesMatrix[1:signals_to_fit, 3] = initial_fit_parameters$positions -\n    initial_fit_parameters$shift_tolerance\n  FeaturesMatrix[1:signals_to_fit, 4] = initial_fit_parameters$positions +\n    initial_fit_parameters$shift_tolerance\n  FeaturesMatrix[1:signals_to_fit, 5] = initial_fit_parameters$widths- initial_fit_parameters$widths * program_parameters$widthtolerance\n  FeaturesMatrix[1:signals_to_fit, 6] = initial_fit_parameters$widths + initial_fit_parameters$widths * program_parameters$widthtolerance\n  FeaturesMatrix[1:signals_to_fit, 7] = 0\n  FeaturesMatrix[1:signals_to_fit, 8] = program_parameters$gaussian\n  FeaturesMatrix[1:signals_to_fit, 9] = initial_fit_parameters$Jcoupling -\n    program_parameters$j_coupling_variation\n  FeaturesMatrix[1:signals_to_fit, 10] = initial_fit_parameters$Jcoupling +\n    program_parameters$j_coupling_variation\n  FeaturesMatrix[1:signals_to_fit, 11] = initial_fit_parameters$multiplicities\n  FeaturesMatrix[1:signals_to_fit, 12] = initial_fit_parameters$roof_effect\n\n\n  FeaturesMatrix[initial_fit_parameters$multiplicities==1, 9:10] = 0\n\n  #Finding of maximum intensity and shift tolerance of every background signal\n  if (BGSigNum>0) {\n    BGSigrightlimits = seq(Xdata[1]-0.005, Xdata[ROIlength]+0.005, length = BGSigNum) -\n      0.005\n    BGSigleftlimits = BGSigrightlimits + 0.01\n\n    peaks = peakdet(Ydata, program_parameters$peakdet_minimum*max(1e-10,max(Ydata)))\n    left = which(peaks$mintab$pos < ROIlength / 5)\n    right = which(peaks$mintab$pos > 4 * ROIlength / 5)\n    dummy = round(seq(1, ROIlength, length = 2 * BGSigNum - 1))\n    BGleftlimits = dummy[c(1, seq(2, length(dummy) - 1, 2))]\n    BGrightlimits = dummy[c(seq(2, length(dummy) - 1, 2), length(dummy))]\n    BGSig_maximums = replicate(BGSigNum, NA)\n    for (ss in 1:BGSigNum)\n      BGSig_maximums[ss] = min(Ydata[BGleftlimits[ss]:BGrightlimits[ss]])\n\n\n    #Parameters of background signals\n    FeaturesMatrix[(signals_to_fit + 1):nrow(FeaturesMatrix), 1] = 0\n    FeaturesMatrix[(signals_to_fit + 1):nrow(FeaturesMatrix), 2] = BGSig_maximums\n    FeaturesMatrix[(signals_to_fit + 1):nrow(FeaturesMatrix), 3] = BGSigrightlimits\n    FeaturesMatrix[(signals_to_fit + 1):nrow(FeaturesMatrix), 4] = BGSigleftlimits\n    # FeaturesMatrix[(signals_to_fit + 1):nrow(FeaturesMatrix), 5] = (1.5 /\n    #                                                                     program_parameters$freq) * 10\n    # FeaturesMatrix[(signals_to_fit + 1):nrow(FeaturesMatrix), 6] = (1.5 /\n    #                                                                      program_parameters$freq) * 15\n    FeaturesMatrix[(signals_to_fit + 1):nrow(FeaturesMatrix), 5] = program_parameters$BG_width-program_parameters$BG_width*program_parameters$BG_width_tolerance\n    FeaturesMatrix[(signals_to_fit + 1):nrow(FeaturesMatrix), 6] = program_parameters$BG_width+program_parameters$BG_width*program_parameters$BG_width_tolerance\n\n    FeaturesMatrix[(signals_to_fit + 1):nrow(FeaturesMatrix), 7] = 0\n    FeaturesMatrix[(signals_to_fit + 1):nrow(FeaturesMatrix), 8] = program_parameters$BG_gaussian_percentage\n    FeaturesMatrix[(signals_to_fit + 1):nrow(FeaturesMatrix), 9] = 0\n    FeaturesMatrix[(signals_to_fit + 1):nrow(FeaturesMatrix), 10] = 0 #j coupling makes no sense with backgorund signals\n    FeaturesMatrix[(signals_to_fit + 1):nrow(FeaturesMatrix), 11] = 0 #arbitrary number used to signal later background signals\n    FeaturesMatrix[(signals_to_fit + 1):nrow(FeaturesMatrix), 12] = 0\n\n\n\n    # optimization of baseline parameters , to be sure that the algorithm doesn ot try ti fot spurious signals as basleine\n    FeaturesMatrix[(signals_to_fit + 1):nrow(FeaturesMatrix),2] = fittingloop_bg(FeaturesMatrix[(signals_to_fit + 1):nrow(FeaturesMatrix),],\n                                Xdata,\n                                created_baseline,\n                                program_parameters)$BG_intensities\n\n\n  }\n\n\n  return(FeaturesMatrix)\n}\n",
    "created" : 1494083244667.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4033166334",
    "id" : "396B4CE0",
    "lastKnownWriteTime" : 1493364349,
    "last_content_update" : 1493364349,
    "path" : "~/GitHub/rDolphin/R/fitting_prep.R",
    "project_path" : "R/fitting_prep.R",
    "properties" : {
    },
    "relative_order" : 18,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}