}
updated_scaled_roi=scaled_roi[ind,,drop=F]
spectra_lag=rep(NA,nrow(updated_scaled_roi))
dummy=apply(updated_scaled_roi, 2, function(x)  median(x,na.rm=T))
for (i in 1:nrow(updated_scaled_roi)) {
d <-ccf(updated_scaled_roi[i,],dummy,type = 'covariance',plot = FALSE)
spectra_lag[i]=d$lag[which.max(d$acf)]
}
visual_roi=original_roi=imported_data$dataset[ind[sort(spectra_lag,index.return=T)$ix],,drop=F]
} else {
visual_roi=original_roi=imported_data$dataset
ind=seq(nrow(imported_data$dataset))
}
ay <- list(tickfont = list(color = "red"),overlaying = "y",side = "right",title = "p value",range = c(0,max(plotdata$value)))
az = list(title = "Intensity",range = c(-1, max(plotdata$value)-1))
p=plot_ly()
for (i in seq(nrow(visual_roi))){
p=p%>%add_lines(x=~imported_data$ppm,y = ~visual_roi[i, ],name=imported_data$Experiments[ ind[i]])
}
p=p%>%add_lines(x=~imported_data$ppm,y = ~p_value_bucketing,name='p value', yaxis = "y2")%>%
layout(xaxis=list(title='ppm',range=c(max(imported_data$ppm),min(imported_data$ppm))),yaxis=az, yaxis2 = ay)
p
p=plot_ly()
for (i in 1:9){
p=p%>%add_lines(x=~imported_data$ppm,y = ~visual_roi[i, ],name=imported_data$Experiments[ ind[i]])
}
p
p=plot_ly()
p=p%>%add_lines(x=~imported_data$ppm,y = ~visual_roi[1, ],name=imported_data$Experiments[ ind[1]])
p
p=p%>%add_lines(x=~imported_data$ppm,y = ~visual_roi[2, ],name=imported_data$Experiments[ ind[2]])
p
p=p%>%add_lines(x=~imported_data$ppm,y = ~visual_roi[3, ],name=imported_data$Experiments[ ind[3]])
p
p=p%>%add_lines(x=~imported_data$ppm,y = ~visual_roi[4, ],name=imported_data$Experiments[ ind[3]])
p=plot_ly()
for (i in seq(nrow(visual_roi))){
spectrum=visual_roi[i, ]
p=p%>%add_lines(x=~imported_data$ppm,y = ~spectrum,name=imported_data$Experiments[ ind[i]])
}
p
p=plot_ly()
for (i in 1:3){
spectrum=visual_roi[i, ]
p=p%>%add_lines(x=~imported_data$ppm,y = ~spectrum,name=imported_data$Experiments[ ind[i]])
}
p
p=plot_ly()
for (i in seq(nrow(visual_roi))){
spectrum=as.numeric(visual_roi[i, ])
p=p%>%add_lines(x=~imported_data$ppm,y = ~spectrum,name=imported_data$Experiments[ ind[i]])
}
p
visual_roi=t(visual_roi)
p=plot_ly()
for (i in seq(nrow(visual_roi))){
p=p%>%add_lines(x=~imported_data$ppm,y = ~visual_roi[,i],name=imported_data$Experiments[ ind[i]])
}
visual_roi=t(visual_roi)
p=plot_ly()
for (i in seq(ncol(visual_roi))){
p=p%>%add_lines(x=~imported_data$ppm,y = ~visual_roi[,i],name=imported_data$Experiments[ ind[i]])
}
visual_roi=t(visual_roi)
p=plot_ly()
for (i in seq(ncol(visual_roi))){
p=p%>%add_lines(x=~imported_data$ppm,y = ~visual_roi[,i],name=imported_data$Experiments[ ind[i]])
}
p
rm(p)
visual_roi=t(visual_roi)
p=plot_ly()
for (i in seq(ncol(visual_roi))){
p=p%>%add_lines(x=~imported_data$ppm,y = ~visual_roi[,i],name=imported_data$Experiments[ ind[i]])
}
visual_roi=t(visual_roi)
p=plot_ly()
for (i in seq(ncol(visual_roi))){
p=p%>%add_lines(x=~imported_data$ppm,y = ~visual_roi[,i],name=imported_data$Experiments[ ind[i]])
}
p
p=plot_ly()
for (i in seq(ncol(visual_roi))){
p=p%>%add_lines(x=~imported_data$ppm,y = ~as.numeric(visual_roi[,i]),name=imported_data$Experiments[ ind[i]])
}
p
p=plot_ly()
for (jj in seq(ncol(visual_roi))){
p=p%>%add_lines(x=~imported_data$ppm,y = ~as.numeric(visual_roi[,jj]))
}
p
p=plot_ly()
for (jj in seq(ncol(visual_roi))){
mm=jj
p=p%>%add_lines(x=~imported_data$ppm,y = ~as.numeric(visual_roi[,mm]))
}
p
p=plot_ly()
for (jj in seq(ncol(visual_roi))){
mm=jj
p=p%>%add_lines(x=~imported_data$ppm,y = ~as.numeric(visual_roi[,mm]),,name='Der')
}
p
p=plot_ly()
for (jj in seq(ncol(visual_roi))){
mm=jj
p=p%>%add_trace(x=~imported_data$ppm,y = ~as.numeric(visual_roi[,mm]))
}
p
install.packages("plotly")
install.packages("plotly")
install.packages("plotly")
install.packages("plotly")
install.packages("plotly")
install.packages("plotly")
load("C:/Bruker/TopSpin3.2/data/MTBLS237/data_analysis/prova4.RData")
imported_data=savedreactivedata$imported_data
if (nrow(imported_data$dataset)>10) {
scaled_roi=scale(imported_data$dataset[ , sort(colMeans(imported_data$dataset),decreasing=T,index.return=T)$ix[1:(ncol(imported_data$dataset)/3)],drop=F])
updated_scaled_roi=scaled_roi
rm_ind=c()
stop=0
ind=seq(nrow(imported_data$dataset))
while ((!is.null(rm_ind)|stop==0)&(nrow(scaled_roi)>15)) {
stop=1
if (length(rm_ind)>0) scaled_roi=scaled_roi[-rm_ind,]
rm_ind=c()
apres <- suppressWarnings(apclusterK(negDistMat(r=2), scaled_roi, K=min(c(dim(scaled_roi)[1]-1,10)),verbose=F))
for (i in 1:length(apres@clusters)) {
if (length(apres@clusters[[i]])==1) rm_ind=c(rm_ind,apres@clusters[[i]][1])
}
ind=apres@exemplars
}
updated_scaled_roi=scaled_roi[ind,,drop=F]
spectra_lag=rep(NA,nrow(updated_scaled_roi))
dummy=apply(updated_scaled_roi, 2, function(x)  median(x,na.rm=T))
for (i in 1:nrow(updated_scaled_roi)) {
d <-ccf(updated_scaled_roi[i,],dummy,type = 'covariance',plot = FALSE)
spectra_lag[i]=d$lag[which.max(d$acf)]
}
visual_roi=original_roi=imported_data$dataset[ind[sort(spectra_lag,index.return=T)$ix],,drop=F]
} else {
visual_roi=original_roi=imported_data$dataset
ind=seq(nrow(imported_data$dataset))
}
# for (i in 1:nrow(original_roi))   visual_roi[i,]=original_roi[i,]+(i-1)*mean(original_roi)
library(apcluster)
linrary(plotly)
library(plotly)
if (nrow(imported_data$dataset)>10) {
scaled_roi=scale(imported_data$dataset[ , sort(colMeans(imported_data$dataset),decreasing=T,index.return=T)$ix[1:(ncol(imported_data$dataset)/3)],drop=F])
updated_scaled_roi=scaled_roi
rm_ind=c()
stop=0
ind=seq(nrow(imported_data$dataset))
while ((!is.null(rm_ind)|stop==0)&(nrow(scaled_roi)>15)) {
stop=1
if (length(rm_ind)>0) scaled_roi=scaled_roi[-rm_ind,]
rm_ind=c()
apres <- suppressWarnings(apclusterK(negDistMat(r=2), scaled_roi, K=min(c(dim(scaled_roi)[1]-1,10)),verbose=F))
for (i in 1:length(apres@clusters)) {
if (length(apres@clusters[[i]])==1) rm_ind=c(rm_ind,apres@clusters[[i]][1])
}
ind=apres@exemplars
}
updated_scaled_roi=scaled_roi[ind,,drop=F]
spectra_lag=rep(NA,nrow(updated_scaled_roi))
dummy=apply(updated_scaled_roi, 2, function(x)  median(x,na.rm=T))
for (i in 1:nrow(updated_scaled_roi)) {
d <-ccf(updated_scaled_roi[i,],dummy,type = 'covariance',plot = FALSE)
spectra_lag[i]=d$lag[which.max(d$acf)]
}
visual_roi=original_roi=imported_data$dataset[ind[sort(spectra_lag,index.return=T)$ix],,drop=F]
} else {
visual_roi=original_roi=imported_data$dataset
ind=seq(nrow(imported_data$dataset))
}
# for (i in 1:nrow(original_roi))   visual_roi[i,]=original_roi[i,]+(i-1)*mean(original_roi)
library(rDolphin)
p_value_bucketing=as.vector(p_values(imported_data$dataset,imported_data$Metadata))
ay <- list(tickfont = list(color = "red"),overlaying = "y",side = "right",title = "p value",range = c(0,max(plotdata$value)))
az = list(title = "Intensity",range = c(-1, max(plotdata$value)-1))
p=plot_ly()
for (i in seq(nrow(visual_roi))){
p=p%>%add_lines(x=~imported_data$ppm,y = ~visual_roi[i, ],name=imported_data$Experiments[ ind[i]])
}
p
p=plot_ly()
for (i in 1:2){
p=p%>%add_lines(x=~imported_data$ppm,y = ~visual_roi[i, ],name=imported_data$Experiments[ ind[i]])
}
p
p=p%>%add_lines(x=~imported_data$ppm,y = ~p_value_bucketing,name='p value', yaxis = "y2")%>%
layout(xaxis=list(title='ppm',range=c(max(imported_data$ppm),min(imported_data$ppm))),yaxis=az, yaxis2 = ay)
ay <- list(tickfont = list(color = "red"),overlaying = "y",side = "right",title = "p value",range = c(0,max(visual_roi)))
az = list(title = "Intensity",range = c(-1, max(visual_roi)-1))
p=plot_ly()
for (i in seq(nrow(visual_roi))){
p=p%>%add_lines(x=~imported_data$ppm,y = ~visual_roi[i, ],name=imported_data$Experiments[ ind[i]])
}
p=p%>%add_lines(x=~imported_data$ppm,y = ~p_value_bucketing,name='p value', yaxis = "y2")%>%
layout(xaxis=list(title='ppm',range=c(max(imported_data$ppm),min(imported_data$ppm))),yaxis=az, yaxis2 = ay)
p
types=unique(imported_data$Metadata[,2])
mediandataset=matrix(NA,length(types),ncol(imported_data$dataset))
for (i in 1:length(types)) mediandataset[i,]=apply(imported_data$dataset[which(imported_data$Metadata[,2]==types[i]),,drop=F],2,median)
ay <- list(tickfont = list(color = "red"),overlaying = "y",side = "right",title = "p value",range = c(0,max(mediandataset)))
ay <- list(tickfont = list(color = "red"),overlaying = "y",side = "right",title = "p value",range = c(0,max(mediandataset)))
az = list(title = "Intensity",range = c(-1, max(mediandataset)-1))
p=plot_ly()
for (i in seq(nrow(mediandataset))){
p=p%>%add_lines(x=~imported_data$ppm,y = ~mediandataset[i, ],name=imported_data$Experiments[ ind[i]])
}
p=p%>%add_lines(x=~imported_data$ppm,y = ~p_value_bucketing,name='p value', yaxis = "y2")%>%
layout(xaxis=list(title='ppm',range=c(max(imported_data$ppm),min(imported_data$ppm))),yaxis=az, yaxis2 = ay)
p
ay <- list(tickfont = list(color = "red"),overlaying = "y",side = "right",title = "p value",range = c(0,max(mediandataset)))
az = list(title = "Intensity",range = c(-1, max(mediandataset)-1))
p=plot_ly()
for (i in seq(nrow(mediandataset))){
p=p%>%add_lines(x=~imported_data$ppm,y = ~mediandataset[i, ],name=types[ ind[i]])
}
p=p%>%add_lines(x=~imported_data$ppm,y = ~p_value_bucketing,name='p value', yaxis = "y2")%>%
layout(xaxis=list(title='ppm',range=c(max(imported_data$ppm),min(imported_data$ppm))),yaxis=az, yaxis2 = ay)
p
types
ay <- list(tickfont = list(color = "red"),overlaying = "y",side = "right",title = "p value",range = c(0,max(mediandataset)))
az = list(title = "Intensity",range = c(-1, max(mediandataset)-1))
p=plot_ly()
for (i in seq(nrow(mediandataset))){
p=p%>%add_lines(x=~imported_data$ppm,y = ~mediandataset[i, ],name=types[ i])
}
p=p%>%add_lines(x=~imported_data$ppm,y = ~p_value_bucketing,name='p value', yaxis = "y2")%>%
layout(xaxis=list(title='ppm',range=c(max(imported_data$ppm),min(imported_data$ppm))),yaxis=az, yaxis2 = ay)
p
library(rDolphin)
rDolphin_GUI()
ROI_data
ROI_profile = ROI_data[ROI_separator[ROI_index, 1]:ROI_separator[ROI_index, 2],]
ROI_buckets = which.min(abs(as.numeric(ROI_profile[1, 1])-imported_data$ppm)):which.min(abs(as.numeric(ROI_profile[1, 2])-imported_data$ppm))
signals_to_quantify = which(ROI_profile[, 5] >= 1)
signals_codes = (ROI_separator[ROI_index, 1]:ROI_separator[ROI_index, 2])[signals_to_quantify]
#Preparation of necessary parameters
program_parameters=imported_data$program_parameters
program_parameters$freq = imported_data$freq
program_parameters$ROI_buckets = ROI_buckets
program_parameters$buck_step = imported_data$buck_step
fitting_type = as.character(ROI_profile[1, 3])
signals_to_quantify = which(ROI_profile[, 5] >= 1)
ROI_buckets = which.min(abs(as.numeric(ROI_profile[1, 1])-imported_data$ppm)):which.min(abs(as.numeric(ROI_profile[1, 2])-imported_data$ppm))
if (length(ROI_buckets)<5) next
if (ROI_buckets[1]>ROI_buckets[2]) ROI_buckets=rev(ROI_buckets)
Xdata= as.numeric(imported_data$ppm[ROI_buckets])
Ydata = as.numeric(imported_data$dataset[spectrum_index, ROI_buckets])
program_parameters$clean_fit = ifelse(fitting_type == "Clean Sum", "Y",
"N")
program_parameters$freq=imported_data$freq
baseline = fitting_prep_integration(Xdata,Ydata,program_parameters,baseline)
Ydatamedian=as.numeric(apply(imported_data$dataset[, ROI_buckets,drop=F],2,median))
integration_variables = integration(program_parameters$clean_fit, Xdata,Ydata,Ydatamedian,baseline[ROI_buckets])
total_signals_parameters[signals_codes,]=c(integration_variables$results_to_save$intensity,integration_variables$results_to_save$shift,rep(NA,5),integration_variables$results_to_save$fitting_error,integration_variables$results_to_save$signal_area_ratio)
fitted_data[ROI_buckets]= integration_variables$plot_data[3,]
ab=import_data("C:/Bruker/TopSpin3.2/data/MTBLS1/data analysis/Parameters_MTBLS1.csv")
ac=profile_model_spectrum(ab$imported_data,ab$imported_data$ROI_data)
ac=profile_model_spectrum(ab$imported_data,ab$imported_data$ROI_data)
ac=profile_model_spectrum(ab,ab$ROI_data)
source('~/GitHub/rDolphin/R/profile_model_spectrum.R')
ac=profile_model_spectrum(ab,ab$ROI_data)
library(rDolphin)
rDolphin_GUI()
ac=profile_model_spectrum(ab,ab$ROI_data)
library(rDolphin)
ac=profile_model_spectrum(ab,ab$ROI_data)
library(baseline)
ac=profile_model_spectrum(ab,ab$ROI_data)
rDolphin_GUI()
dummy = which(is.na(ROI_data[, 1]))
if (length(dummy)==0) dummy=dim(ROI_data)[1]+1
lal=which(duplicated(ROI_data[-dummy,1:2])==F)
ROI_separator = cbind(lal, c(lal[-1] - 1, dim(ROI_data[-dummy,])[1]))
# indicators=matrix(NA,nrow(ROI_data),2,dimnames=list(imported_data$signals_names)))
total_signals_parameters=matrix(NA,nrow(ROI_data),9,dimnames=list(imported_data$signals_names))
colnames(total_signals_parameters)=c("intensity",	" chemical shift",	"half_band_width",	"gaussian %",	"J coupling",	"multiplicities",	"roof_effect","fitting error","signal / total area ratio")
quartile_spectrum = as.numeric(apply(imported_data$dataset, 2, function(x)
quantile(x, 0.75,na.rm=T)))
spectrum_index = which.min(apply(imported_data$dataset, 1, function(x)
sqrt(mean((x - quartile_spectrum) ^ 2
,na.rm=T))))
baseline=baseline.rollingBall(rbind(imported_data$dataset[spectrum_index,],imported_data$dataset[spectrum_index,]),5,5)$baseline[1,]
plotdata = data.frame(Xdata=as.numeric(imported_data$ppm),Ydata = as.numeric(imported_data$dataset[spectrum_index,]))
fitted_data=rep(0,length(imported_data$ppm))
pb   <- txtProgressBar(1, nrow(ROI_separator), style=3)
dummy = which(is.na(ROI_data[, 1]))
if (length(dummy)==0) dummy=dim(ROI_data)[1]+1
lal=which(duplicated(ROI_data[-dummy,1:2])==F)
ROI_separator = cbind(lal, c(lal[-1] - 1, dim(ROI_data[-dummy,])[1]))
# indicators=matrix(NA,nrow(ROI_data),2,dimnames=list(imported_data$signals_names)))
total_signals_parameters=matrix(NA,nrow(ROI_data),9,dimnames=list(imported_data$signals_names))
colnames(total_signals_parameters)=c("intensity",	" chemical shift",	"half_band_width",	"gaussian %",	"J coupling",	"multiplicities",	"roof_effect","fitting error","signal / total area ratio")
quartile_spectrum = as.numeric(apply(imported_data$dataset, 2, function(x)
quantile(x, 0.75,na.rm=T)))
spectrum_index = which.min(apply(imported_data$dataset, 1, function(x)
sqrt(mean((x - quartile_spectrum) ^ 2
,na.rm=T))))
baseline=baseline.rollingBall(rbind(imported_data$dataset[spectrum_index,],imported_data$dataset[spectrum_index,]),5,5)$baseline[1,]
plotdata = data.frame(Xdata=as.numeric(imported_data$ppm),Ydata = as.numeric(imported_data$dataset[spectrum_index,]))
fitted_data=rep(0,length(imported_data$ppm))
pb   <- txtProgressBar(1, nrow(ROI_separator), style=3)
dummy = which(is.na(ROI_data[, 1]))
dummy = which(is.na(ROI_data[, 1]))
length(dummy)==0
dummy=dim(ROI_data)[1]+1
lal=which(duplicated(ROI_data[-dummy,1:2])==F)
ROI_separator = cbind(lal, c(lal[-1] - 1, dim(ROI_data[-dummy,])[1]))
total_signals_parameters=matrix(NA,nrow(ROI_data),9,dimnames=list(imported_data$signals_names))
colnames(total_signals_parameters)=c("intensity",	" chemical shift",	"half_band_width",	"gaussian %",	"J coupling",	"multiplicities",	"roof_effect","fitting error","signal / total area ratio")
quartile_spectrum = as.numeric(apply(imported_data$dataset, 2, function(x)
quantile(x, 0.75,na.rm=T)))
spectrum_index = which.min(apply(imported_data$dataset, 1, function(x)
sqrt(mean((x - quartile_spectrum) ^ 2
,na.rm=T))))
baseline=baseline.rollingBall(rbind(imported_data$dataset[spectrum_index,],imported_data$dataset[spectrum_index,]),5,5)$baseline[1,]
plotdata = data.frame(Xdata=as.numeric(imported_data$ppm),Ydata = as.numeric(imported_data$dataset[spectrum_index,]))
fitted_data=rep(0,length(imported_data$ppm))
pb   <- txtProgressBar(1, nrow(ROI_separator), style=3)
for (ROI_index in seq_along(ROI_separator[, 1])) {
#Loading of every ROI parameters
ROI_profile = ROI_data[ROI_separator[ROI_index, 1]:ROI_separator[ROI_index, 2],]
ROI_buckets = which.min(abs(as.numeric(ROI_profile[1, 1])-imported_data$ppm)):which.min(abs(as.numeric(ROI_profile[1, 2])-imported_data$ppm))
signals_to_quantify = which(ROI_profile[, 5] >= 1)
signals_codes = (ROI_separator[ROI_index, 1]:ROI_separator[ROI_index, 2])[signals_to_quantify]
#Preparation of necessary parameters
program_parameters=imported_data$program_parameters
program_parameters$freq = imported_data$freq
program_parameters$ROI_buckets = ROI_buckets
program_parameters$buck_step = imported_data$buck_step
fitting_type = as.character(ROI_profile[1, 3])
signals_to_quantify = which(ROI_profile[, 5] >= 1)
ROI_buckets = which.min(abs(as.numeric(ROI_profile[1, 1])-imported_data$ppm)):which.min(abs(as.numeric(ROI_profile[1, 2])-imported_data$ppm))
if (length(ROI_buckets)<5) next
if (ROI_buckets[1]>ROI_buckets[2]) ROI_buckets=rev(ROI_buckets)
Xdata= as.numeric(imported_data$ppm[ROI_buckets])
Ydata = as.numeric(imported_data$dataset[spectrum_index, ROI_buckets])
# If the quantification is through integration with or without baseline
if (fitting_type == "Clean Sum" ||
fitting_type == "Baseline Sum") {
program_parameters$clean_fit = ifelse(fitting_type == "Clean Sum", "Y",
"N")
program_parameters$freq=imported_data$freq
baseline = fitting_prep_integration(Xdata,Ydata,program_parameters,baseline[ROI_buckets])
Ydatamedian=as.numeric(apply(imported_data$dataset[, ROI_buckets,drop=F],2,median))
integration_variables = integration(program_parameters$clean_fit, Xdata,Ydata,Ydatamedian,baseline)
total_signals_parameters[signals_codes,]=c(integration_variables$results_to_save$intensity,integration_variables$results_to_save$shift,rep(NA,5),integration_variables$results_to_save$fitting_error,integration_variables$results_to_save$signal_area_ratio)
#preparation of output
fitted_data[ROI_buckets]= integration_variables$plot_data[3,]
} else if (fitting_type == "Clean Fitting" || fitting_type ==
"Baseline Fitting") {
program_parameters$clean_fit='N'
initial_fit_parameters = ROI_profile[, 5:11,drop=F]
#Adaptation of the info of the parameters into a single matrix and preparation (if necessary) of the background signals that will conform the baseline
FeaturesMatrix = fitting_prep(Xdata,
Ydata,
ROI_profile[, 5:11,drop=F],
program_parameters,baseline[ROI_buckets])
#Calculation of the parameters that will achieve the best fitting
dummy = fittingloop(FeaturesMatrix,
Xdata,
Ydata,
program_parameters)
signals_parameters=dummy$signals_parameters
#Fitting of the signals
multiplicities=FeaturesMatrix[,11]
roof_effect=FeaturesMatrix[,12]
fitted_signals = signal_fitting(signals_parameters,
Xdata,multiplicities,roof_effect,Ydata,program_parameters$freq)
dim(signals_parameters) = c(5, length(signals_parameters)/5)
rownames(signals_parameters) = c(
'intensity',
'shift',
'half_band_width',
'gaussian',
'J_coupling'
)
signals_parameters=rbind(signals_parameters,multiplicities,roof_effect)
dummy = output_generator(
signals_to_quantify,
fitted_signals,
Ydata,
Xdata,
signals_parameters,multiplicities
)
output_data=dummy$output_data
fitted_data[ROI_buckets]=output_data$fitted_sum
total_signals_parameters[signals_codes,]=cbind(t(signals_parameters[,signals_to_quantify]),output_data$fitting_error[signals_to_quantify],output_data$signal_area_ratio[signals_to_quantify])
}
setTxtProgressBar(pb, ROI_index)
}
for (ROI_index in seq_along(ROI_separator[, 1])) {
for (ROI_index in seq_along(ROI_separator[, 1])) {
#Loading of every ROI parameters
ROI_profile = ROI_data[ROI_separator[ROI_index, 1]:ROI_separator[ROI_index, 2],]
ROI_buckets = which.min(abs(as.numeric(ROI_profile[1, 1])-imported_data$ppm)):which.min(abs(as.numeric(ROI_profile[1, 2])-imported_data$ppm))
signals_to_quantify = which(ROI_profile[, 5] >= 1)
signals_codes = (ROI_separator[ROI_index, 1]:ROI_separator[ROI_index, 2])[signals_to_quantify]
#Preparation of necessary parameters
program_parameters=imported_data$program_parameters
program_parameters$freq = imported_data$freq
program_parameters$ROI_buckets = ROI_buckets
program_parameters$buck_step = imported_data$buck_step
fitting_type = as.character(ROI_profile[1, 3])
signals_to_quantify = which(ROI_profile[, 5] >= 1)
ROI_buckets = which.min(abs(as.numeric(ROI_profile[1, 1])-imported_data$ppm)):which.min(abs(as.numeric(ROI_profile[1, 2])-imported_data$ppm))
if (length(ROI_buckets)<5) next
if (ROI_buckets[1]>ROI_buckets[2]) ROI_buckets=rev(ROI_buckets)
Xdata= as.numeric(imported_data$ppm[ROI_buckets])
Ydata = as.numeric(imported_data$dataset[spectrum_index, ROI_buckets])
# If the quantification is through integration with or without baseline
if (fitting_type == "Clean Sum" ||
fitting_type == "Baseline Sum") {
program_parameters$clean_fit = ifelse(fitting_type == "Clean Sum", "Y",
"N")
program_parameters$freq=imported_data$freq
baseline = fitting_prep_integration(Xdata,Ydata,program_parameters,baseline[ROI_buckets])
Ydatamedian=as.numeric(apply(imported_data$dataset[, ROI_buckets,drop=F],2,median))
integration_variables = integration(program_parameters$clean_fit, Xdata,Ydata,Ydatamedian,baseline)
total_signals_parameters[signals_codes,]=c(integration_variables$results_to_save$intensity,integration_variables$results_to_save$shift,rep(NA,5),integration_variables$results_to_save$fitting_error,integration_variables$results_to_save$signal_area_ratio)
#preparation of output
fitted_data[ROI_buckets]= integration_variables$plot_data[3,]
} else if (fitting_type == "Clean Fitting" || fitting_type ==
"Baseline Fitting") {
program_parameters$clean_fit='N'
initial_fit_parameters = ROI_profile[, 5:11,drop=F]
#Adaptation of the info of the parameters into a single matrix and preparation (if necessary) of the background signals that will conform the baseline
FeaturesMatrix = fitting_prep(Xdata,
Ydata,
ROI_profile[, 5:11,drop=F],
program_parameters,baseline[ROI_buckets])
#Calculation of the parameters that will achieve the best fitting
dummy = fittingloop(FeaturesMatrix,
Xdata,
Ydata,
program_parameters)
signals_parameters=dummy$signals_parameters
#Fitting of the signals
multiplicities=FeaturesMatrix[,11]
roof_effect=FeaturesMatrix[,12]
fitted_signals = signal_fitting(signals_parameters,
Xdata,multiplicities,roof_effect,Ydata,program_parameters$freq)
dim(signals_parameters) = c(5, length(signals_parameters)/5)
rownames(signals_parameters) = c(
'intensity',
'shift',
'half_band_width',
'gaussian',
'J_coupling'
)
signals_parameters=rbind(signals_parameters,multiplicities,roof_effect)
dummy = output_generator(
signals_to_quantify,
fitted_signals,
Ydata,
Xdata,
signals_parameters,multiplicities
)
output_data=dummy$output_data
fitted_data[ROI_buckets]=output_data$fitted_sum
total_signals_parameters[signals_codes,]=cbind(t(signals_parameters[,signals_to_quantify]),output_data$fitting_error[signals_to_quantify],output_data$signal_area_ratio[signals_to_quantify])
}
setTxtProgressBar(pb, ROI_index)
}
rDolphin_GUI()
ROI_profile = ROI_data[ROI_separator[ROI_index, 1]:ROI_separator[ROI_index, 2],]
ROI_buckets = which.min(abs(as.numeric(ROI_profile[1, 1])-imported_data$ppm)):which.min(abs(as.numeric(ROI_profile[1, 2])-imported_data$ppm))
signals_to_quantify = which(ROI_profile[, 5] >= 1)
signals_codes = (ROI_separator[ROI_index, 1]:ROI_separator[ROI_index, 2])[signals_to_quantify]
#Preparation of necessary parameters
program_parameters=imported_data$program_parameters
program_parameters$freq = imported_data$freq
program_parameters$ROI_buckets = ROI_buckets
program_parameters$buck_step = imported_data$buck_step
fitting_type = as.character(ROI_profile[1, 3])
signals_to_quantify = which(ROI_profile[, 5] >= 1)
ROI_buckets = which.min(abs(as.numeric(ROI_profile[1, 1])-imported_data$ppm)):which.min(abs(as.numeric(ROI_profile[1, 2])-imported_data$ppm))
if (length(ROI_buckets)<5) next
if (ROI_buckets[1]>ROI_buckets[2]) ROI_buckets=rev(ROI_buckets)
Xdata= as.numeric(imported_data$ppm[ROI_buckets])
Ydata = as.numeric(imported_data$dataset[spectrum_index, ROI_buckets])
program_parameters$clean_fit='N'
initial_fit_parameters = ROI_profile[, 5:11,drop=F]
#Adaptation of the info of the parameters into a single matrix and preparation (if necessary) of the background signals that will conform the baseline
FeaturesMatrix = fitting_prep(Xdata,
Ydata,
ROI_profile[, 5:11,drop=F],
program_parameters,baseline[ROI_buckets])
devtools::install_github("danielcanueto/rDolphin") #installs rDolphin
library(rDolphin)
rDolphin_GUI()
library(rDolphin)
devtools::install_github("danielcanueto/rDolphin") #installs rDolphin
devtools::install_github("danielcanueto/rDolphin",force=T) #installs rDolphin
library(rDolphin)
rDolphin_GUI()
library(rDolphin)
rDolphin_GUI()
install.packages("roxygen2")
devtools::install_github("danielcanueto/rDolphin") #installs rDolphin
library(rDolphin)
rDolphin_GUI()
library(rDolphin)
rDolphin_GUI()
library(rDolphin)
rDolphin_GUI()
